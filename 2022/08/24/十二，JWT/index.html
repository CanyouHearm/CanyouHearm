
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Hexo</title>
        <meta name="author" content="John Doe">
        <meta name="description" content="">
        <meta name="keywords" content="">
        <link rel="icon" href="">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Hexo</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Hexo</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        
<div class="article">
    <div>
        <h1> </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/8/24
        </span>
        
        
    </div>
    <div class="content" v-pre>
        <h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>JWT的全称是Json Web Token。它遵循JSON格式，将用户信息加密到token里，服务器不保存任何用户信息，只保存密钥信息，通过使用特定加密算法验证token，通过token验证用户身份。基于token的身份验证可以替代传统的cookie+session身份验证方法。</p>
<p>jwt由三个部分组成：<code>header</code>.<code>payload</code>.<code>signature</code></p>
<p><strong>header：</strong></p>
<p>使用一个JSON格式字符串声明令牌的类型和签名用的算法等，形如：</p>
<pre><code>&#123;
  &quot;alg&quot;: &quot;HS256&quot;,
  &quot;typ&quot;: &quot;JWT&quot;
&#125;
</code></pre>
<p>header声明的一些标准</p>
<p><img src="/%E5%8D%81%E4%BA%8C%EF%BC%8CJWT.assets/image-20220411091230813.png" alt="image-20220411091230813"></p>
<p><strong>payload：</strong></p>
<p>Payload 部分也是一个 JSON 对象，是用户数据以及一些元数据有关的声明，用以声明权限。包含官方字段和私有字段</p>
<p>eg：</p>
<pre><code>&#123;
        &quot;user_role&quot; : &quot;finn&quot;,    //当前登录用户
    &quot;iss&quot;: &quot;admin&quot;,          //该JWT的签发者
    &quot;iat&quot;: 1573440582,        //签发时间
    &quot;exp&quot;: 1573940267,        //过期时间
    &quot;nbf&quot;: 1573440582,         //该时间之前不接收处理该Token
    &quot;domain&quot;: &quot;example.com&quot;,   //面向的用户
    &quot;jti&quot;: &quot;dff4214121e83057655e10bd9751d657&quot;   //Token唯一标识
&#125;
</code></pre>
<p><strong>signature：</strong></p>
<p>signature的功能是保护token完整性。</p>
<p>生成方法为将header和payload两个部分联结起来，然后通过header部分指定的算法，计算出签名。</p>
<p>抽象成公式就是</p>
<pre><code>signature = HMAC-SHA256(base64urlEncode(header) + &#39;.&#39; + base64urlEncode(payload), secret_key)
</code></pre>
<p>值得注意的是，编码header和payload时使用的编码方式为<code>base64urlencode</code>，<code>base64url</code>编码是<code>base64</code>的修改版，为了方便在网络中传输使用了不同的编码表，它不会在末尾填充”&#x3D;”号，并将标准Base64中的”+”和”&#x2F;“分别改成了”-“和”_”。</p>
<p><strong>生成完整的token</strong>：</p>
<p>python的<code>Pyjwt</code>使用示例如下</p>
<pre><code>import jwt

encoded_jwt = jwt.encode(&#123;&#39;user_name&#39;: &#39;admin&#39;&#125;, &#39;key&#39;, algorithm=&#39;HS256&#39;)
print(encoded_jwt)
print(jwt.decode(encoded_jwt, &#39;key&#39;, algorithms=[&#39;HS256&#39;]))
</code></pre>
<p><strong>解码</strong></p>
<p><a target="_blank" rel="noopener" href="https://jwt.io/">https://jwt.io/</a></p>
<h2 id="漏洞发现"><a href="#漏洞发现" class="headerlink" title="漏洞发现"></a>漏洞发现</h2><p>公钥泄露</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><h4 id="空加密算法"><a href="#空加密算法" class="headerlink" title="空加密算法"></a>空加密算法</h4><p>JWT支持使用空加密算法，可以在header中指定alg为<code>None</code>。</p>
<p>这样的话，只要把signature设置为空（即不添加signature字段），提交到服务器，任何token都可以通过服务器的验证。</p>
<p>空加密算法的设计初衷是用于调试的，但是如果某天开发人员脑阔瓦特了，在生产环境中开启了空加密算法，缺少签名算法，jwt保证信息不被篡改的功能就失效了。攻击者只需要把alg字段设置为None，就可以在payload中构造身份信息，伪造用户身份。</p>
<h4 id="修改RSA加密算法为HMAC"><a href="#修改RSA加密算法为HMAC" class="headerlink" title="修改RSA加密算法为HMAC"></a>修改RSA加密算法为HMAC</h4><p>JWT中最常用的两种算法为<code>HMAC</code>和<code>RSA</code>。</p>
<p><code>HMAC</code>是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）的缩写，它是一种对称加密算法，使用相同的密钥对传输信息进行加解密。</p>
<p><code>RSA</code>则是一种非对称加密算法，使用私钥加密明文，公钥解密密文。</p>
<p>在HMAC和RSA算法中，都是使用私钥对<code>signature</code>字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token。</p>
<p>私钥通常很难获取，而公钥有时却可以通过某些途径获取</p>
<p>这时，将JWT的加密算法修改为HMAC，并使用公钥作为算法密钥，对token进行签名，发送到服务端。</p>
<p>服务器端会将RSA的公钥（<code>pub</code>）视为当前算法（HMAC）的密钥，使用HS256算法对接收到的签名进行验证。而HMAC算法只使用一个密钥。</p>
<h3 id="密钥爆破"><a href="#密钥爆破" class="headerlink" title="密钥爆破"></a>密钥爆破</h3><p>对 JWT 的密钥爆破需要在一定的前提下进行：</p>
<ul>
<li>知悉JWT使用的加密算法</li>
<li>一段有效的、已签名的token</li>
<li>签名用的密钥不复杂（弱密钥）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/brendan-rius/c-jwt-cracker">https://github.com/brendan-rius/c-jwt-cracker</a></p>
<h3 id="修改kid参数"><a href="#修改kid参数" class="headerlink" title="修改kid参数"></a>修改kid参数</h3><p><code>kid</code>是jwt header中的一个可选参数，全称是<code>key ID</code>，它用于指定加密算法的密钥</p>
<p>eg：</p>
<pre><code>&#123;
    &quot;alg&quot; : &quot;HS256&quot;,
    &quot;typ&quot; : &quot;jwt&quot;,
    &quot;kid&quot; : &quot;/home/jwt/.ssh/pem&quot;
&#125;
</code></pre>
<h4 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h4><p><code>kid</code>参数用于读取密钥文件，但系统并不会知道用户想要读取的到底是不是密钥文件，所以，如果在没有对参数进行过滤的前提下，攻击者是可以使用kid读取到系统的任意文件的。</p>
<pre><code>&#123;
    &quot;alg&quot; : &quot;HS256&quot;,
    &quot;typ&quot; : &quot;jwt&quot;,
    &quot;kid&quot; : &quot;/etc/passwd&quot;
&#125;
</code></pre>
<h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><p><code>kid</code>也可以从数据库中提取数据，这时候就有可能造成SQL注入攻击，通过构造SQL语句来获取数据或者是绕过signature的验证</p>
<pre><code>&#123;
    &quot;alg&quot; : &quot;HS256&quot;,
    &quot;typ&quot; : &quot;jwt&quot;,
    &quot;kid&quot; : &quot;key11111111&#39; || union select &#39;secretkey&#39; -- &quot;
&#125;
</code></pre>
<h4 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h4><p>对<code>kid</code>参数过滤不严也可能会出现命令注入问题，但是利用条件比较苛刻。如果服务器后端使用的是Ruby，在读取密钥文件时使用了<code>open</code>函数，通过构造参数就可能造成命令注入。</p>
<pre><code>&quot;/path/to/key_file|whoami&quot;
</code></pre>
<p>对于其他的语言，例如php，如果代码中使用的是<code>exec</code>或者是<code>system</code>来读取密钥文件，那么同样也可以造成命令注入，当然这个可能性就比较小了。</p>
<h3 id="修改JKU-x2F-X5U参数"><a href="#修改JKU-x2F-X5U参数" class="headerlink" title="修改JKU&#x2F;X5U参数"></a>修改JKU&#x2F;X5U参数</h3><ul>
<li>JWS：Signed JWT，签名过的jwt</li>
<li>JWK：JWT的密钥，也就是我们常说的scret；</li>
<li>JWE：Encrypted JWT部分payload经过加密的jwt；</li>
<li>jku：”jku” (JSON Web Key Set URL) 是jwt header中的一个字段，字段内容是一个URI，该URI用于指定用于验证令牌秘钥的服务器，该服务器用于回复jwk。</li>
<li>x5u：”x5u” 也是jwt header中的一个字段，指向一组X509公共证书的URL，与jku功能类似</li>
<li>X.509 标准<ul>
<li>X.509 标准是密码学里公钥证书的格式标准,包括TLS&#x2F;SSL(WWW万维网安全浏览的基石)在内的众多 Internet协议都应用了X.509 证书）</li>
</ul>
</li>
</ul>
<p><code>JKU</code>的全称是”JSON Web Key Set URL”，用于指定一组用于验证令牌的密钥的URL。类似于<code>kid</code>，<code>JKU</code>也可以由用户指定输入数据，如果没有经过严格过滤，就可以指定一组自定义的密钥文件，并指定web应用使用该组密钥来验证token。</p>
<p><code>X5U</code>则以URI的形式数允许攻击者指定用于验证令牌的<strong>公钥证书或证书链</strong>，与<code>JKU</code>的攻击利用方式类似。</p>
<p>jku工作原理</p>
<p>1，用户携带jws访问应用</p>
<p>2，应用解码jwws得到jku</p>
<p>3，应用根据jku访问jwk服务器</p>
<p>4，应用得到jwk</p>
<p>5，应用使用jwk验证用户jws</p>
<p>6，验证通过，正常回显</p>
<p>攻击：</p>
<ol>
<li>攻击者使用伪造的JWS访问应用，jku字段指向自己控制的服务器。</li>
<li>应用程序得到jku后对恶意服务器进行访问，得到伪造的JWK。</li>
<li>攻击者的JWS成功得到验证，进而可以越权访问应用</li>
</ol>
<h3 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h3><p>JWT保证的是数据传输过程中的完整性而不是机密性。</p>
<p>由于payload是使用<code>base64url</code>编码的，所以相当于明文传输，如果在payload中携带了敏感信息（如存放密钥对的文件路径），单独对payload部分进行<code>base64url</code>解码，就可以读取到payload中携带的信息。</p>
<h3 id="错误的堆叠加密-签名验证假设"><a href="#错误的堆叠加密-签名验证假设" class="headerlink" title="错误的堆叠加密+签名验证假设"></a>错误的堆叠加密+签名验证假设</h3><h4 id="错误的堆叠加密"><a href="#错误的堆叠加密" class="headerlink" title="错误的堆叠加密"></a>错误的堆叠加密</h4><p>这种攻击发生在单个的或者嵌套的JWE中</p>
<p>假设JWE如下所示：</p>
<pre><code>header : ...

    payload: &quot;admin&quot; : false

             &quot;uid&quot;   : 123

             &quot;umail&quot; : 123@126.com

             ...

JWE Main

    protected / unprotected

    recipients:

        en_key : key1

        en_key : key2

    cipher : xxx
</code></pre>
<p>在攻击者不修改秘钥的情况下，对于ciphertext进行修改。往往会导致解密的失败。但是，即使是失败，很多JWT的解密也是会有输出的，在没有附加认证数据（ADD）的情况下更是如此。攻击者对于ciphertext的内容进行修改，可能会让其他的数据无法解密，但是只要最后输出的payload中，有“admin”:true。 其目的就已经达到了。</p>
<h4 id="签名假设验证"><a href="#签名假设验证" class="headerlink" title="签名假设验证"></a>签名假设验证</h4><p>这种攻击发生嵌套的JWS中。我们想象一个嵌套的JWS,其包括了两层的部分，其结构如下：</p>
<pre><code>JWT Main

    JWT Sub1

        payload

        Signature2

    Signature
</code></pre>
<p>现在，攻击者通过一定的方式，能够让外层的验证通过的时候，此时，系统还应该检查内层的签名数据，如果不检查，攻击者就可以随意篡改payload的数据，来达到越权的目的。</p>
<h3 id="无效椭圆曲线攻击"><a href="#无效椭圆曲线攻击" class="headerlink" title="无效椭圆曲线攻击"></a>无效椭圆曲线攻击</h3><p>椭圆曲线加密是一种非常安全的方式，甚至从某种程度上而言，比RSA更加安全。关于椭圆曲线的算法，在此不展开。</p>
<p>在椭圆曲线加密中，公钥是椭圆曲线上的一个点，而私钥只是一个位于特殊但非常大的范围内的数字。 如果未验证对这些操作的输入，那攻击者就可以进行设计，从而恢复私钥。</p>
<p>而这种攻击已在过去中得到证实。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1515376">https://cloud.tencent.com/developer/article/1515376</a></p>
<h3 id="替换攻击"><a href="#替换攻击" class="headerlink" title="替换攻击"></a>替换攻击</h3><p>攻击者需要至少获得两种不同的JWT，然后攻击者可以将令牌中的一个或者两个用在其他的地方。</p>
<h4 id="不同接收方攻击"><a href="#不同接收方攻击" class="headerlink" title="不同接收方攻击"></a>不同接收方攻击</h4><p>我们可以设想一个业务逻辑如下：</p>
<blockquote>
<p>Auth 机构，有着自己的私钥，并且给 App1 和 App2 发放了两个公钥，用于验证签名；</p>
<p>Attacker 利用自己的秘钥登录了 App1。</p>
</blockquote>
<p>此时 Auth 机构给 Attacker 下发了一个 附带签名的JWT，其payload内容为：</p>
<pre><code>&#123;
    &#39;uname&#39;:&#39;Attacker&#39;
    &#39;role&#39; :&#39;admin&#39;
&#125;
</code></pre>
<p>此时，如果 Attacker 知道 App1 和 App2 的公钥是同一个Auth 签发的话，他可以利用这个JWT去登录 App2，从而获取Admin权限。</p>
<h4 id="相同接收方攻击-x2F-跨越式JWT-same-recipient-x2F-Cross-JWT"><a href="#相同接收方攻击-x2F-跨越式JWT-same-recipient-x2F-Cross-JWT" class="headerlink" title="相同接收方攻击&#x2F;跨越式JWT same recipient&#x2F;Cross JWT"></a>相同接收方攻击&#x2F;跨越式JWT same recipient&#x2F;Cross JWT</h4><p>我们可以设想一个业务逻辑如下：</p>
<blockquote>
<p>在同一站点下，有两个应用程序，wordpress和phpmyadmin，他们都利用了相同的秘钥对和算法来验证JWT签名；</p>
<p>站点管理员知道 Different Recipient 的问题，所以给 wordpress 的应用增加了 aud 验证，但是 phpmyadmin 的用户人数较少，没有增加 aud 的验证；</p>
<p>Attacker 利用自己的秘钥登录了 wordpress。</p>
</blockquote>
<p>此时 站点 给 Attacker 下发了一个 附带签名的JWT，其payload内容为：</p>
<pre><code>&#123;
    &#39;uname&#39;:&#39;Attacker&#39;
    &#39;role&#39; :&#39;writer&#39;
    &#39;aud&#39; :&#39;shaobaobaoer.cn/wordpress&#39;
    &#39;iss&#39; :&#39;shaobaobaoer.cn&#39;
&#125;
</code></pre>
<p>这个JWT看似非常安全，但这仅仅是对于 wordpress 的应用程序而言，。从而Attacker 可以以 writer 的身份登录 phpmyadmin。</p>
<h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>1，不允许出现 none 的方法；</p>
<p>将开启 alg : none 作为一种额外的配置选项。</p>
<p>2，不允许 HS256等对称加密 算法读取秘钥。jwtpy就是限制了这种方法。当读取到 类似于 “— xxx key —“ 的参数的时候应抛出错误；</p>
<p>将秘钥与验证算法相互匹配。</p>
<p>3，对于JWE而言，应当解密所有数据，而非从解密的结果中提取单个需要的数据。另外，利用附加认证数据ADD，也是非常好的选择</p>
<p>对于嵌套JWS而言，应当验证所有层面的签名是否正确，而非验证最外层的签名是否正确就足够。</p>
<p>4，检查传递给任何公共函数的所有输入是否有效是解决这类攻击的关键点。验证内容包括公钥是所选曲线的有效椭圆曲线点，以及私钥位于有效值范围内</p>
<p>5，在jwt中带上 aud 声明，比如 aud : App1 这样。来限定该jwt只能用于App1。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/6776">https://xz.aliyun.com/t/6776</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/236830">https://www.anquanke.com/post/id/236830</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/180874.html">https://www.freebuf.com/articles/web/180874.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/181261.html">https://www.freebuf.com/articles/web/181261.html</a></p>

    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 20xx - 2022 Hexo
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @John Doe
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>